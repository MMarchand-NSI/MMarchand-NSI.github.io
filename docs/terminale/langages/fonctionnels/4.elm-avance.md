# 4. AvancÃ© - Fonctions d'Ordre SupÃ©rieur

## ğŸ“š Introduction

Tu as maintenant maÃ®trisÃ© la rÃ©cursion sur les listes. Il est temps de dÃ©couvrir une abstraction puissante : **les fonctions qui prennent d'autres fonctions en paramÃ¨tres**.

---

## 1. Les Fonctions sont des Valeurs

### En Elm, les fonctions sont comme des nombres

```elm
-- Un nombre
x : Int
x = 42

-- Une fonction
double : Int -> Int
double n = n * 2

-- On peut passer une fonction en paramÃ¨tre !
appliquer : (Int -> Int) -> Int -> Int
appliquer fonction valeur = fonction valeur
--        â†‘               â†‘       â†‘
--        fonction       nombre   appelle la fonction
```

**Exemple d'utilisation :**
```elm
appliquer double 5
--> 10

appliquer (\x -> x + 1) 5
--> 6
```

---

## 2. Fonctions Anonymes (Lambda)

### Syntaxe : `\param -> expression`

Une **fonction anonyme** (ou **lambda**) est une fonction sans nom, dÃ©finie sur place.

```elm
-- Fonction normale (avec nom)
double : Int -> Int
double x = x * 2

-- Fonction anonyme (sans nom)
\x -> x * 2
```

### Exemples

```elm
-- Lambda simple
\x -> x + 1

-- Lambda avec plusieurs paramÃ¨tres
\x y -> x + y

-- Lambda avec condition
\x -> if x > 0 then x else 0

-- Lambda avec pattern matching
\lst -> case lst of
    Vide -> 0
    Cons _ q -> 1 + taille q
```

### Pourquoi utiliser des lambdas ?

**Cas 1 : Fonction utilisÃ©e une seule fois**
```elm
-- âŒ DÃ©finir une fonction nommÃ©e pour un usage unique
estPair : Int -> Bool
estPair x = modBy 2 x == 0

resultat = filter estPair maListe

-- âœ… Lambda : plus concis
resultat = filter (\x -> modBy 2 x == 0) maListe
```

**Cas 2 : Fonction trop simple pour mÃ©riter un nom**
```elm
-- Ajouter 10 Ã  chaque Ã©lÃ©ment
ajouterDix = map (\x -> x + 10) maListe
```

---

## 3. Fonctions d'Ordre SupÃ©rieur

### DÃ©finition

Une **fonction d'ordre supÃ©rieur** est une fonction qui :
- Prend une ou plusieurs fonctions en paramÃ¨tres, ET/OU
- Retourne une fonction

### Exemples que tu connais dÃ©jÃ  !

```elm
-- take : prend n et une liste
take : Int -> Liste a -> Liste a

-- Mais on peut le voir comme :
-- take prend n et RETOURNE une fonction qui prend une liste
take : Int -> (Liste a -> Liste a)
```

**En Elm, toutes les fonctions Ã  plusieurs paramÃ¨tres sont en fait des fonctions d'ordre supÃ©rieur !**

---

## 4. La Fonction `foldr` : Le Pattern Ultime

### Observation

Regarde ces fonctions que tu as Ã©crites :

```elm
taille : Liste a -> Int
taille lst =
    case lst of
        Vide -> 0
        Cons _ queue -> 1 + taille queue

somme : Liste Int -> Int
somme lst =
    case lst of
        Vide -> 0
        Cons tete queue -> tete + somme queue

concat : Liste a -> Liste a -> Liste a
concat lst1 lst2 =
    case (lst1, lst2) of
        (Vide, _) -> lst2
        (Cons t q, _) -> Cons t (concat q lst2)
```

**Elles suivent TOUTES le mÃªme pattern !**
1. Cas de base : `Vide -> valeur`
2. Cas rÃ©cursif : `Cons tete queue -> combiner tete (rÃ©cursion queue)`

### `foldr` capture ce pattern

```elm
foldr : (a -> b -> b) -> b -> Liste a -> b
foldr   combiner         base   liste     = rÃ©sultat
```

**Lecture :** 
- `combiner` : fonction qui combine un Ã©lÃ©ment avec le rÃ©sultat du reste
- `base` : valeur Ã  retourner pour la liste vide
- `liste` : la liste Ã  traiter
- `rÃ©sultat` : le rÃ©sultat final

### ImplÃ©mentation de `foldr`

```elm
foldr : (a -> b -> b) -> b -> Liste a -> b
foldr combiner base liste =
    case liste of
        Vide -> 
            base
        Cons tete queue -> 
            combiner tete (foldr combiner base queue)
--          â†‘        â†‘     â†‘
--          fonction  Ã©lÃ©ment  rÃ©sultat du reste
```

### Visualisation

```elm
-- Liste
Cons 1 (Cons 2 (Cons 3 Vide))

-- foldr f base [1, 2, 3]
f    1 (f    2 (f    3 base))

-- On "remplace" Cons par f et Vide par base !
```

---

## 5. RÃ©Ã©crire avec `foldr`

### 5.1. `taille`

**Version manuelle :**
```elm
taille : Liste a -> Int
taille lst =
    case lst of
        Vide -> 0
        Cons _ queue -> 1 + taille queue
```

**Identifions le pattern :**
- Valeur de base : `0`
- Combinaison : `1 + rÃ©sultat_du_reste`
- La tÃªte ne nous intÃ©resse pas : on l'ignore

**Avec `foldr` :**
```elm
taille : Liste a -> Int
taille lst =
    foldr (\tete acc -> 1 + acc) 0 lst
--        â†‘     â†‘       â†‘         â†‘
--        Î»  Ã©lÃ©ment  accumulateur base
```

**Encore plus court :**
```elm
taille : Liste a -> Int
taille = foldr (\_ acc -> 1 + acc) 0
```

**Trace d'exÃ©cution :**
```elm
taille [1, 2, 3]
= foldr (\_ acc -> 1 + acc) 0 [1, 2, 3]
= (\_ acc -> 1 + acc) 1 (foldr (\_ acc -> 1 + acc) 0 [2, 3])
= 1 + ((\_ acc -> 1 + acc) 2 (foldr (\_ acc -> 1 + acc) 0 [3]))
= 1 + (1 + ((\_ acc -> 1 + acc) 3 (foldr (\_ acc -> 1 + acc) 0 [])))
= 1 + (1 + (1 + 0))
= 3
```

### 5.2. `somme`

**Version manuelle :**
```elm
somme : Liste Int -> Int
somme lst =
    case lst of
        Vide -> 0
        Cons tete queue -> tete + somme queue
```

**Pattern :**
- Base : `0`
- Combinaison : `tete + rÃ©sultat`

**Avec `foldr` :**
```elm
somme : Liste Int -> Int
somme lst =
    foldr (\tete acc -> tete + acc) 0 lst
```

**Version ultra-courte :**
```elm
somme : Liste Int -> Int
somme = foldr (+) 0
--            â†‘
--            L'opÃ©rateur + est dÃ©jÃ  une fonction (Int -> Int -> Int)
```

**Pourquoi Ã§a marche ?**
```elm
(+) : Int -> Int -> Int
-- (+) est une fonction qui prend 2 Int et retourne un Int
-- C'est exactement ce que foldr attend !

foldr (+) 0 [1, 2, 3]
= 1 + (2 + (3 + 0))
= 6
```

### 5.3. `concat`

**Version manuelle :**
```elm
concat : Liste a -> Liste a -> Liste a
concat lst1 lst2 =
    case lst1 of
        Vide -> lst2
        Cons t q -> Cons t (concat q lst2)
```

**Pattern :**
- Base : `lst2` (pas `Vide` !)
- Combinaison : `Cons tete rÃ©sultat`

**Avec `foldr` :**
```elm
concat : Liste a -> Liste a -> Liste a
concat lst1 lst2 =
    foldr Cons lst2 lst1
--        â†‘    â†‘    â†‘
--        constructeur  base  liste Ã  parcourir
```

**Trace :**
```elm
concat [1, 2] [3, 4]
= foldr Cons [3, 4] [1, 2]
= Cons 1 (foldr Cons [3, 4] [2])
= Cons 1 (Cons 2 (foldr Cons [3, 4] []))
= Cons 1 (Cons 2 [3, 4])
= [1, 2, 3, 4]
```

### 5.4. `tousVrais`

**Version manuelle :**
```elm
tousVrais : Liste Bool -> Bool
tousVrais lst =
    case lst of
        Vide -> True
        Cons tete queue -> tete && tousVrais queue
```

**Avec `foldr` :**
```elm
tousVrais : Liste Bool -> Bool
tousVrais = foldr (&&) True
--                â†‘    â†‘
--                ET   base (promesse non violÃ©e)
```

**Trace :**
```elm
tousVrais [True, True, False]
= foldr (&&) True [True, True, False]
= True && (True && (False && True))
= True && (True && False)
= False
```

### 5.5. `auMoinsUnVrai`

**Version manuelle :**
```elm
auMoinsUnVrai : Liste Bool -> Bool
auMoinsUnVrai lst =
    case lst of
        Vide -> False
        Cons tete queue -> tete || auMoinsUnVrai queue
```

**Avec `foldr` :**
```elm
auMoinsUnVrai : Liste Bool -> Bool
auMoinsUnVrai = foldr (||) False
--                    â†‘    â†‘
--                    OU   base (aucun trouvÃ©)
```

### 5.6. `ajouterFin`

**Version manuelle :**
```elm
ajouterFin : a -> Liste a -> Liste a
ajouterFin e lst =
    case lst of
        Vide -> Cons e Vide
        Cons tete queue -> Cons tete (ajouterFin e queue)
```

**Avec `foldr` :**
```elm
ajouterFin : a -> Liste a -> Liste a
ajouterFin e lst =
    foldr Cons (Cons e Vide) lst
--        â†‘    â†‘
--        reconstructeur  base = [e]
```

**Trace :**
```elm
ajouterFin 9 [1, 2, 3]
= foldr Cons [9] [1, 2, 3]
= Cons 1 (Cons 2 (Cons 3 [9]))
= [1, 2, 3, 9]
```

---

## 6. Nouvelles Fonctions avec `foldr`

### 6.1. `map` : Transformer chaque Ã©lÃ©ment

```elm
-- Applique une fonction Ã  chaque Ã©lÃ©ment
map : (a -> b) -> Liste a -> Liste b
map f lst =
    foldr (\tete acc -> Cons (f tete) acc) Vide lst
--         â†‘           â†‘
--         transforme  ajoute au rÃ©sultat
```

**Exemple :**
```elm
map (\x -> x * 2) [1, 2, 3]
--> [2, 4, 6]

map (\x -> x > 5) [3, 7, 2, 9]
--> [False, True, False, True]
```

**Trace :**
```elm
map (\x -> x * 2) [1, 2, 3]
= foldr (\tete acc -> Cons (tete * 2) acc) Vide [1, 2, 3]
= Cons (1*2) (foldr (...) Vide [2, 3])
= Cons 2 (Cons (2*2) (foldr (...) Vide [3]))
= Cons 2 (Cons 4 (Cons (3*2) (foldr (...) Vide [])))
= Cons 2 (Cons 4 (Cons 6 Vide))
= [2, 4, 6]
```

### 6.2. `filter` : Garder certains Ã©lÃ©ments

```elm
-- Garde les Ã©lÃ©ments qui satisfont un prÃ©dicat
filter : (a -> Bool) -> Liste a -> Liste a
filter predicate lst =
    foldr (\tete acc ->
        if predicate tete then
            Cons tete acc
        else
            acc
    ) Vide lst
```

**Exemple :**
```elm
filter (\x -> x > 5) [3, 7, 2, 9, 1]
--> [7, 9]

filter (\x -> modBy 2 x == 0) [1, 2, 3, 4, 5, 6]
--> [2, 4, 6]
```

### 6.3. `compte` avec `foldr`

```elm
compte : a -> Liste a -> Int
compte e lst =
    foldr (\tete acc ->
        if tete == e then
            1 + acc
        else
            acc
    ) 0 lst
```

### 6.4. `dupliquer` avec `foldr`

```elm
dupliquer : Liste a -> Liste a
dupliquer lst =
    foldr (\tete acc -> Cons tete (Cons tete acc)) Vide lst
--         â†‘                â†‘            â†‘
--         Ã©lÃ©ment       1Ã¨re fois   2Ã¨me fois
```

**Trace :**
```elm
dupliquer [1, 2]
= foldr (\tete acc -> Cons tete (Cons tete acc)) Vide [1, 2]
= Cons 1 (Cons 1 (foldr (...) Vide [2]))
= Cons 1 (Cons 1 (Cons 2 (Cons 2 (foldr (...) Vide []))))
= Cons 1 (Cons 1 (Cons 2 (Cons 2 Vide)))
= [1, 1, 2, 2]
```

---

## 7. Comprendre les Types de `foldr`

```elm
foldr : (a -> b -> b) -> b -> Liste a -> b
--       â†‘       â†‘      â†‘    â†‘         â†‘
--       |       |      |    |         rÃ©sultat final
--       |       |      |    liste d'Ã©lÃ©ments de type a
--       |       |      valeur de dÃ©part (type b)
--       |       accumulateur (rÃ©sultat partiel)
--       Ã©lÃ©ment de la liste
```

**Exemples de types concrets :**

```elm
-- taille
foldr : (a -> Int -> Int) -> Int -> Liste a -> Int
--       â†‘    â†‘     â†‘        â†‘      â†‘          â†‘
--       elem  acc   acc     base   liste    rÃ©sultat

-- somme
foldr : (Int -> Int -> Int) -> Int -> Liste Int -> Int

-- concat
foldr : (a -> Liste a -> Liste a) -> Liste a -> Liste a -> Liste a

-- map
foldr : (a -> Liste b -> Liste b) -> Liste b -> Liste a -> Liste b
--       â†‘          â†‘                    â†‘         â†‘          â†‘
--       elem    rÃ©sultat partiel     []      liste    nouvelle liste
```

---

## 8. Composition de Fonctions

### L'opÃ©rateur `>>`

```elm
(>>) : (a -> b) -> (b -> c) -> (a -> c)
--     fonction1   fonction2   fonction composÃ©e
```

**Exemple :**
```elm
-- Au lieu de
resultat = somme (map (\x -> x * 2) maListe)

-- On peut Ã©crire
doubleEtSomme = (map (\x -> x * 2)) >> somme
resultat = doubleEtSomme maListe
```

### ChaÃ®ner des transformations

```elm
-- Calculer la somme des carrÃ©s des nombres pairs
sommeCarresPairs : Liste Int -> Int
sommeCarresPairs =
    filter (\x -> modBy 2 x == 0)  -- Garde les pairs
    >> map (\x -> x * x)           -- Met au carrÃ©
    >> somme                       -- Additionne

-- Utilisation
sommeCarresPairs [1, 2, 3, 4, 5]
--> 2Â² + 4Â² = 4 + 16 = 20
```

---

## 9. Quand Utiliser `foldr` ?

### âœ… **Utilise `foldr` quand :**

1. **Tu parcours toute la liste**
   ```elm
   taille, somme, concat, tousVrais
   ```

2. **Tu construis une nouvelle structure**
   ```elm
   map, filter, dupliquer
   ```

3. **Tu accumules un rÃ©sultat**
   ```elm
   somme, compte
   ```

4. **Le pattern rÃ©cursif est clair**
   - Cas de base Ã©vident
   - Combinaison simple

### âŒ **N'utilise PAS `foldr` quand :**

1. **Tu veux arrÃªter tÃ´t**
   ```elm
   -- contient : doit s'arrÃªter dÃ¨s qu'on trouve
   contient e lst =
       case lst of
           Vide -> False
           Cons tete queue ->
               if tete == e then
                   True  -- âœ… S'arrÃªte ici
               else
                   contient e queue
   
   -- foldr parcourt TOUTE la liste, mÃªme aprÃ¨s avoir trouvÃ©
   ```

2. **La rÃ©cursion est complexe**
   ```elm
   -- fusion de deux listes : besoin de dÃ©construire les 2
   -- triFusion : rÃ©cursion sur 2 moitiÃ©s
   ```

3. **Tu as besoin de l'index**
   ```elm
   -- take, drop : nÃ©cessitent un compteur
   ```

---

## 10. `foldl` : Variante de Gauche Ã  Droite

```elm
foldl : (a -> b -> b) -> b -> Liste a -> b
foldl f acc lst =
    case lst of
        Vide -> acc
        Cons tete queue -> 
            foldl f (f tete acc) queue
--          â†‘       â†‘
--          applique d'abord, puis continue
```

### DiffÃ©rence avec `foldr`

```elm
-- foldr : associe Ã  DROITE
foldr (+) 0 [1, 2, 3]
= 1 + (2 + (3 + 0))

-- foldl : associe Ã  GAUCHE
foldl (+) 0 [1, 2, 3]
= ((0 + 1) + 2) + 3
```

### Quand utiliser `foldl` ?

**Pour `renverse` : `foldl` est plus efficace**
```elm
renverse : Liste a -> Liste a
renverse = foldl (\tete acc -> Cons tete acc) Vide

-- Trace:
-- renverse [1, 2, 3]
-- = foldl Cons Vide [1, 2, 3]
-- = foldl Cons (Cons 1 Vide) [2, 3]
-- = foldl Cons (Cons 2 (Cons 1 Vide)) [3]
-- = foldl Cons (Cons 3 (Cons 2 (Cons 1 Vide))) []
-- = [3, 2, 1]
```

---

## 11. Exercices pour RÃ©flÃ©chir

**Ne code pas ces exercices**, juste rÃ©flÃ©chis Ã  comment tu les ferais :

1. **Avec `foldr`, comment Ã©crirais-tu `removeAllElt` ?**
   - Quelle est la base ?
   - Comment combiner un Ã©lÃ©ment avec le rÃ©sultat ?

2. **Peut-on Ã©crire `take` avec `foldr` ?**
   - ProblÃ¨me : `take` a besoin d'un compteur
   - Solution : utiliser une fonction auxiliaire avec un compteur

3. **Comment Ã©crire `renverse` avec `foldr` ?**
   - Base : `Vide`
   - Combinaison : `ajouterFin tete acc`
   - Mais attention : O(nÂ²) !

---

## ğŸ¯ RÃ©sumÃ©

### Concepts ClÃ©s

1. **Fonctions anonymes** : `\param -> expression`
2. **Fonctions d'ordre supÃ©rieur** : prennent des fonctions en paramÃ¨tres
3. **`foldr`** : capture le pattern rÃ©cursif sur les listes

### Le Pattern `foldr`

```elm
-- Pattern manuel
maFonction lst =
    case lst of
        Vide -> base
        Cons tete queue -> combiner tete (maFonction queue)

-- Avec foldr
maFonction = foldr combiner base
```

### Quand Utiliser

| Situation | Outil |
|-----------|-------|
| RÃ©cursion simple sur 1 liste | `foldr` |
| Besoin d'arrÃªter tÃ´t | RÃ©cursion manuelle |
| RÃ©cursion complexe | RÃ©cursion manuelle |
| Transformer/filtrer | `map`/`filter` (basÃ©s sur `foldr`) |

---

## ğŸ’¡ Citation

> "Don't repeat yourself. If you see a pattern, abstract it."
> 
> â€” Principe de programmation fonctionnelle

`foldr` est l'abstraction du pattern de rÃ©cursion sur les listes. Au lieu d'Ã©crire 100 fois le mÃªme `case lst of...`, tu l'Ã©cris une fois et tu le rÃ©utilises ! ğŸš€
