# L'OpÃ©rateur Pipe `|>` en Elm

## ğŸ¯ Le ProblÃ¨me

### Code difficile Ã  lire

```elm
-- Calculer la taille de la liste renversÃ©e
resultat = taille (renverse (pairs [1, 2, 3, 4, 5]))
```

**ProblÃ¨me :** On doit lire **de l'intÃ©rieur vers l'extÃ©rieur** !

```
1. pairs [1, 2, 3, 4, 5]      --> [2, 4]
2. renverse [2, 4]            --> [4, 2]
3. taille [4, 2]              --> 2
```

**Mais le code s'Ã©crit dans l'ordre inverse de la lecture !** ğŸ˜µ

---

## ğŸ’¡ La Solution : L'OpÃ©rateur `|>`

### Syntaxe

```elm
valeur |> fonction
```

**Se lit :** "Prends `valeur` et applique-lui `fonction`"

### Exemple Simple

```elm
-- Sans pipe
taille [1, 2, 3]
--> 3

-- Avec pipe
[1, 2, 3] |> taille
--> 3
```

**Les deux sont Ã©quivalents !**

---

## ğŸ“– Lire de Gauche Ã  Droite

### ChaÃ®ner des OpÃ©rations

```elm
-- âŒ Sans pipe : lecture compliquÃ©e
resultat = taille (renverse (pairs [1, 2, 3, 4, 5]))

-- âœ… Avec pipe : lecture naturelle
resultat = 
    [1, 2, 3, 4, 5]
        |> pairs        -- [2, 4]
        |> renverse     -- [4, 2]
        |> taille       -- 2
```

**Ordre de lecture = ordre d'exÃ©cution !** ğŸ¯

### Visualisation

```
[1, 2, 3, 4, 5]
    â†“ pairs
[2, 4]
    â†“ renverse
[4, 2]
    â†“ taille
2
```

---

## ğŸ”§ Comment Ã‡a Marche ?

### DÃ©finition de `|>`

```elm
(|>) : a -> (a -> b) -> b
(|>) valeur fonction = fonction valeur
```

**Traduction :** 
- Prends une valeur de type `a`
- Prends une fonction qui accepte `a` et retourne `b`
- Applique la fonction Ã  la valeur
- Retourne le rÃ©sultat de type `b`

### Transformation

```elm
-- Ceci
x |> f

-- Est transformÃ© en cela
f x

-- Donc
[1, 2, 3] |> taille
-- Devient
taille [1, 2, 3]
```

---

## ğŸ“ Exemples Pratiques

### Exemple 1 : Traitement de Liste

```elm
-- Calculer la somme des nombres pairs
resultat =
    [1, 2, 3, 4, 5, 6]
        |> pairs        -- [2, 4, 6]
        |> somme        -- 12

-- Ã‰quivalent sans pipe
resultat = somme (pairs [1, 2, 3, 4, 5, 6])
```

### Exemple 2 : Avec des Fonctions Ã  Plusieurs ParamÃ¨tres

```elm
-- take : Int -> Liste a -> Liste a
-- On peut l'utiliser avec |> !

[1, 2, 3, 4, 5]
    |> take 3       -- [1, 2, 3]
    |> somme        -- 6

-- Ã‰quivalent
somme (take 3 [1, 2, 3, 4, 5])
```

**Astuce :** La valeur avant `|>` devient le **dernier paramÃ¨tre** de la fonction.

### Exemple 3 : Pipeline Complexe

```elm
traiterDonnees : Liste Int -> Int
traiterDonnees lst =
    lst
        |> pairs           -- Garde les pairs
        |> take 3          -- Prends les 3 premiers
        |> dupliquer       -- Duplique chaque Ã©lÃ©ment
        |> somme           -- Additionne tout

traiterDonnees [1, 2, 3, 4, 5, 6, 7, 8]
--> (2 + 2 + 4 + 4 + 6 + 6) = 24
```

### Exemple 4 : Avec des Lambdas

```elm
[1, 2, 3, 4, 5]
    |> (\lst -> take 2 lst)    -- Lambda qui prend 2 Ã©lÃ©ments
    |> somme                    -- 3

-- Ou plus simple avec application partielle
[1, 2, 3, 4, 5]
    |> take 2
    |> somme
```

---

## ğŸ¨ Style et LisibilitÃ©

### Quand Utiliser le Pipe ?

#### âœ… Oui : Plusieurs Transformations

```elm
-- Lisible avec pipe
resultat =
    maListe
        |> fonction1
        |> fonction2
        |> fonction3
```

#### âœ… Oui : OpÃ©rations SÃ©quentielles

```elm
-- Clair et naturel
[1, 2, 3, 4, 5]
    |> filter (\x -> x > 2)
    |> map (\x -> x * 2)
    |> somme
```

#### âŒ Non : Une Seule Fonction

```elm
-- âŒ Pas nÃ©cessaire
resultat = [1, 2, 3] |> taille

-- âœ… Plus simple
resultat = taille [1, 2, 3]
```

#### âŒ Non : Fonction Avec Plusieurs Arguments

```elm
-- âŒ Peu clair
resultat = 
    liste1
        |> concat liste2

-- âœ… Plus clair
resultat = concat liste1 liste2
```

---

## ğŸ”„ Indentation et Format

### Style RecommandÃ©

```elm
-- Chaque Ã©tape sur une ligne
resultat =
    [1, 2, 3, 4, 5]
        |> pairs
        |> renverse
        |> taille
```

### Avec Commentaires

```elm
traiterCommande : Liste Int -> Int
traiterCommande commande =
    commande
        |> pairs           -- Filtrer les quantitÃ©s paires
        |> take 10         -- Maximum 10 articles
        |> somme           -- Total de la commande
        |> (\x -> x * 2)   -- Doubler pour promotion
```

### Longues Lignes

```elm
-- Si les fonctions sont longues, indente plus
resultat =
    maDonnee
        |> fonctionAvecUnNomTresLong
        |> autreFonctionCompliquee
        |> encoreUneFonction
```

---

## âš¡ Cas Pratiques dans Tes Exercices

### Exemple 1 : `renverse` avec `ajouterFin`

```elm
-- Version compliquÃ©e Ã  lire
renverse : Liste a -> Liste a
renverse lst =
    case lst of
        Vide -> Vide
        Cons tete queue -> ajouterFin tete (renverse queue)

-- Avec pipe (plus clair dans certains contextes)
-- Note: ici le pipe n'aide pas vraiment, 
-- c'est juste pour montrer qu'on peut l'utiliser
```

### Exemple 2 : Tester des Fonctions

```elm
-- Au lieu de
test1 = taille (renverse (pairs lstEx1))

-- Avec pipe
test1 = 
    lstEx1
        |> pairs
        |> renverse
        |> taille

-- Beaucoup plus clair ce qu'on teste !
```

### Exemple 3 : `range` avec `take`

```elm
-- CrÃ©er [0, 1, 2, 3, 4]
cinqPremiers : Liste Int
cinqPremiers =
    range 10         -- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        |> take 5    -- [0, 1, 2, 3, 4]
```

### Exemple 4 : Combiner avec `concat`

```elm
-- ConcatÃ©ner puis traiter
combineEtTraite : Liste Int -> Liste Int -> Int
combineEtTraite lst1 lst2 =
    concat lst1 lst2     -- Combine les listes
        |> pairs         -- Garde les pairs
        |> somme         -- Additionne

-- Utilisation
combineEtTraite [1, 2, 3] [4, 5, 6]
--> (2 + 4 + 6) = 12
```

---

## ğŸ¤” Questions FrÃ©quentes

### Q1 : Puis-je mÃ©langer parenthÃ¨ses et pipes ?

**Oui !**

```elm
resultat =
    (take 3 [1, 2, 3, 4, 5])
        |> somme
        |> (\x -> x * 2)

-- Ou
resultat =
    [1, 2, 3, 4, 5]
        |> take 3
        |> somme
        |> (\x -> x * 2)
```

### Q2 : Comment avec des fonctions Ã  2+ paramÃ¨tres ?

**Application partielle !**

```elm
-- concat : Liste a -> Liste a -> Liste a
-- On donne le premier argument, pas le deuxiÃ¨me

[1, 2, 3]
    |> concat [4, 5, 6]    -- concat [1,2,3] [4,5,6]
    |> taille               -- 6

-- La valeur avant |> devient le DERNIER argument
```

### Q3 : Peut-on utiliser `|>` avec nos propres fonctions ?

**Oui, avec n'importe quelle fonction !**

```elm
maFonction : Int -> Int
maFonction x = x * 2 + 1

5 |> maFonction
--> 11

-- MÃªme avec des fonctions complexes
monTraitement : Liste Int -> Bool
monTraitement lst = taille lst > 5

[1, 2, 3, 4, 5, 6] |> monTraitement
--> True
```

### Q4 : Quelle est la limite ?

**Aucune ! Tu peux chaÃ®ner autant que tu veux**

```elm
resultat =
    [1, 2, 3, 4, 5]
        |> fonction1
        |> fonction2
        |> fonction3
        |> fonction4
        |> fonction5
        |> fonction6
-- etc...
```

---

## ğŸ“ Exercices de ComprÃ©hension

**Transforme ces expressions avec `|>` :**

### Exercice 1
```elm
-- Sans pipe
taille (renverse [1, 2, 3])

-- Avec pipe
[1, 2, 3] |> renverse |> taille
```

### Exercice 2
```elm
-- Sans pipe
somme (pairs (take 5 [1, 2, 3, 4, 5, 6]))

-- Avec pipe
[1, 2, 3, 4, 5, 6]
    |> take 5
    |> pairs
    |> somme
```

### Exercice 3
```elm
-- Sans pipe
taille (concat [1, 2] [3, 4, 5])

-- Avec pipe
[1, 2]
    |> concat [3, 4, 5]
    |> taille
-- RÃ©sultat : 5
```

---

## ğŸš€ Comparaison avec d'Autres Langages

### JavaScript (mÃ©thodes chaÃ®nÃ©es)
```javascript
// JavaScript
[1, 2, 3, 4, 5]
    .filter(x => x % 2 === 0)
    .map(x => x * 2)
    .reduce((a, b) => a + b, 0)
```

### Elm (avec pipe)
```elm
-- Elm
[1, 2, 3, 4, 5]
    |> filter (\x -> modBy 2 x == 0)
    |> map (\x -> x * 2)
    |> foldl (+) 0
```

**MÃªme principe, syntaxe diffÃ©rente !**

### Unix (pipes en ligne de commande)
```bash
# Bash
cat fichier.txt | grep "mot" | wc -l
```

### Elm
```elm
-- MÃªme concept en Elm
fichierContenu
    |> filtrerLignes "mot"
    |> compterLignes
```

---

## âœ… RÃ©sumÃ© : Pourquoi Utiliser `|>` ?

### Avantages

1. **LisibilitÃ©** : Ordre naturel gauche â†’ droite
2. **ClartÃ©** : Chaque transformation est explicite
3. **DÃ©bogage** : Facile de commenter/dÃ©commenter une Ã©tape
4. **Style** : Code Elm idiomatique

### Le Pattern

```elm
donnees
    |> transformation1
    |> transformation2
    |> transformation3
    |> resultat
```

**Se lit comme une recette de cuisine !** ğŸ‘¨â€ğŸ³

---

## ğŸ¯ Conseil Final

**Utilise `|>` quand tu as 2+ transformations sÃ©quentielles.**

```elm
-- âœ… Bon usage
resultat =
    maListe
        |> pairs
        |> somme

-- âŒ Pas nÃ©cessaire
resultat = maListe |> taille

-- âœ… Mieux
resultat = taille maListe
```

**Le pipe est ton ami pour Ã©crire du code clair et lisible !** ğŸš€

---

## ğŸ“š Pour Aller Plus Loin

Une fois que tu maÃ®trises `|>`, tu peux dÃ©couvrir :
- `<|` (pipe inversÃ©, moins courant)
- `>>` (composition de fonctions)
- `<<` (composition inversÃ©e)

Mais pour l'instant, **`|>` suffit largement !** ğŸ’ª
