# 2. Le Type `Maybe`

## ğŸ¯ Le ProblÃ¨me

### Que Retourner Quand Ã‡a Ã‰choue ?

```elm
-- Comment Ã©crire cette fonction ?
dernierElement : Liste a -> ???
dernierElement lst = ...

-- ProblÃ¨me : Que retourner si la liste est vide ?
dernierElement Vide = ???  -- Pas d'Ã©lÃ©ment Ã  retourner !
```

**En d'autres langages :**

- **Python/Java** : `None` ou `null` â†’ crashes possibles
- **C** : Valeur spÃ©ciale (-1, 0) â†’ ambiguÃ«
- **Exceptions** : Lourd et imprÃ©visible

**En Elm : Le type `Maybe` !** âœ¨

---

## ğŸ“¦ DÃ©finition de `Maybe`

### Le Type

```elm
type Maybe a
    = Nothing       -- Absence de valeur
    | Just a        -- PrÃ©sence d'une valeur de type a
```

**Lecture :** Un `Maybe a` est **SOIT** `Nothing` (rien), **SOIT** `Just` une valeur de type `a`.

### Exemples de Valeurs

```elm
-- Maybe Int
Nothing             -- Pas d'entier
Just 42             -- L'entier 42

-- Maybe String
Nothing             -- Pas de chaÃ®ne
Just "hello"        -- La chaÃ®ne "hello"

-- Maybe Bool
Nothing             -- Pas de boolÃ©en
Just True           -- Le boolÃ©en True
```

---

## ğŸ’¡ Intuition

### Maybe = BoÃ®te Optionnelle

```elm
Just 5       -- BoÃ®te contenant 5
Nothing      -- BoÃ®te vide
```

**Analogie :**

- **BoÃ®te fermÃ©e avec un cadeau** â†’ `Just valeur`
- **BoÃ®te vide** â†’ `Nothing`

### En Comparaison avec d'Autres Langages

| Langage | Ã‰quivalent | ProblÃ¨me |
|---------|------------|----------|
| Python | `None` | Pas typÃ©, crash possible |
| Java | `null` | NullPointerException |
| JavaScript | `null`/`undefined` | Confusion |
| Rust | `Option<T>` | MÃªme concept ! âœ… |
| Haskell | `Maybe a` | Identique âœ… |
| **Elm** | `Maybe a` | SÃ»r Ã  la compilation âœ… |

---

## ğŸ” Utilisation avec les Listes

### Exemple 1 : `premier` (head)

```elm
-- Renvoie le premier Ã©lÃ©ment d'une liste
premier : Liste a -> Maybe a
premier lst =
    case lst of
        Vide -> Nothing                    -- Pas d'Ã©lÃ©ment
        Cons tete queue -> Just tete       -- On a un Ã©lÃ©ment !
```

**Utilisation :**
```elm
premier [1, 2, 3]
--> Just 1

premier []
--> Nothing
```

### Exemple 2 : `dernierElement`

```elm
-- Renvoie le dernier Ã©lÃ©ment d'une liste
dernierElement : Liste a -> Maybe a
dernierElement lst =
    case lst of
        Vide -> Nothing                              -- Liste vide
        Cons tete Vide -> Just tete                  -- Un seul Ã©lÃ©ment
        Cons _ queue -> dernierElement queue         -- Continue la recherche
```

**Utilisation :**
```elm
dernierElement [1, 2, 3]
--> Just 3

dernierElement []
--> Nothing

dernierElement [42]
--> Just 42
```

**Trace d'exÃ©cution :**
```
dernierElement [1, 2, 3]
= dernierElement [2, 3]          (pas le dernier)
= dernierElement [3]             (pas le dernier)
= Just 3                         (un seul Ã©lÃ©ment !)
```

---

## ğŸ¨ Pattern Matching sur Maybe

### DÃ©construire un Maybe

```elm
case monMaybe of
    Nothing -> ...       -- Cas oÃ¹ il n'y a rien
    Just valeur -> ...   -- Cas oÃ¹ on a une valeur
```

### Exemple : Afficher un RÃ©sultat

```elm
afficherResultat : Maybe Int -> String
afficherResultat resultat =
    case resultat of
        Nothing -> "Aucun rÃ©sultat"
        Just n -> "Le rÃ©sultat est : " ++ String.fromInt n
```

**Utilisation :**
```elm
afficherResultat (Just 42)
--> "Le rÃ©sultat est : 42"

afficherResultat Nothing
--> "Aucun rÃ©sultat"
```

---

## ğŸ› ï¸ Fonctions Utiles sur Maybe

### `Maybe.withDefault` : Valeur par DÃ©faut

```elm
-- Si Nothing, utilise la valeur par dÃ©faut
Maybe.withDefault : a -> Maybe a -> a

-- Exemples
Maybe.withDefault 0 (Just 5)
--> 5

Maybe.withDefault 0 Nothing
--> 0

Maybe.withDefault "inconnu" (Just "Alice")
--> "Alice"

Maybe.withDefault "inconnu" Nothing
--> "inconnu"
```

**Utilisation pratique :**
```elm
-- Obtenir le premier Ã©lÃ©ment ou 0 par dÃ©faut
premierOuZero : Liste Int -> Int
premierOuZero lst =
    premier lst
        |> Maybe.withDefault 0

premierOuZero [1, 2, 3]
--> 1

premierOuZero []
--> 0
```

### `Maybe.map` : Transformer la Valeur

```elm
-- Applique une fonction si Just, sinon reste Nothing
Maybe.map : (a -> b) -> Maybe a -> Maybe b

-- Exemples
Maybe.map (\x -> x * 2) (Just 5)
--> Just 10

Maybe.map (\x -> x * 2) Nothing
--> Nothing

Maybe.map String.length (Just "hello")
--> Just 5
```

**Cas d'usage :**
```elm
-- Doubler le premier Ã©lÃ©ment
doublerPremier : Liste Int -> Maybe Int
doublerPremier lst =
    premier lst
        |> Maybe.map (\x -> x * 2)

doublerPremier [5, 10, 15]
--> Just 10

doublerPremier []
--> Nothing
```

---

## âš ï¸ Erreurs Courantes

### Erreur 1 : Oublier le `Just`

```elm
-- âŒ ERREUR
premier : Liste a -> Maybe a
premier lst =
    case lst of
        Vide -> Nothing
        Cons tete queue -> tete  -- Manque Just !

-- âœ… CORRECT
premier : Liste a -> Maybe a
premier lst =
    case lst of
        Vide -> Nothing
        Cons tete queue -> Just tete
```

### Erreur 2 : Oublier le Cas `Nothing`

```elm
-- âŒ ERREUR : Pattern matching incomplet
utiliser : Maybe Int -> Int
utiliser m =
    case m of
        Just x -> x * 2
        -- Manque le cas Nothing !

-- âœ… CORRECT
utiliser : Maybe Int -> Int
utiliser m =
    case m of
        Just x -> x * 2
        Nothing -> 0  -- Valeur par dÃ©faut
```

### Erreur 3 : Retourner `Nothing` au Lieu de `Just Nothing`

```elm
-- Type Maybe (Maybe a) : un Maybe dans un Maybe !

trouverPuis : (a -> Maybe b) -> Maybe a -> Maybe (Maybe b)
trouverPuis f m =
    case m of
        Nothing -> Nothing           -- Pas de valeur de base
        Just x -> Just (f x)         -- Just du rÃ©sultat (qui peut Ãªtre Nothing)
        
-- Exemple
trouverPuis premier (Just [1, 2, 3])
--> Just (Just 1)

trouverPuis premier (Just [])
--> Just Nothing  -- âš ï¸ Pas juste Nothing !

trouverPuis premier Nothing
--> Nothing
```

---

## ğŸ”— ChaÃ®ner des Maybe

### ProblÃ¨me : Maybe ImbriquÃ©s

```elm
-- Obtenir le premier Ã©lÃ©ment du dernier Ã©lÃ©ment (si c'est une liste de listes)

-- Version naÃ¯ve
getPremierDuDernier : Liste (Liste a) -> Maybe (Maybe a)
getPremierDuDernier listes =
    case dernierElement listes of
        Nothing -> Nothing
        Just derniereListe -> Just (premier derniereListe)

-- RÃ©sultat : Maybe (Maybe a) ğŸ˜•
```

### Solution : `Maybe.andThen`

```elm
-- Maybe.andThen : (a -> Maybe b) -> Maybe a -> Maybe b
-- "ChaÃ®ne" les Maybe sans les imbriquer

getPremierDuDernier : Liste (Liste a) -> Maybe a
getPremierDuDernier listes =
    dernierElement listes
        |> Maybe.andThen premier

-- Exemples
getPremierDuDernier [[1, 2], [3, 4], [5, 6]]
--> Just 5  (premier de [5, 6])

getPremierDuDernier [[1, 2], [3, 4], []]
--> Nothing  (dernier = [], qui n'a pas de premier)

getPremierDuDernier []
--> Nothing  (pas de dernier)
```

---

## ğŸ“ Exemple Complet : `minimum`

### Trouver le Minimum d'une Liste

```elm
-- Renvoie le plus petit Ã©lÃ©ment (s'il existe)
minimum : Liste comparable -> Maybe comparable
minimum lst =
    case lst of
        Vide -> Nothing
        Cons premier reste ->
            case minimum reste of
                Nothing -> Just premier          -- Premier est le seul Ã©lÃ©ment
                Just minReste ->
                    if premier < minReste then
                        Just premier             -- Premier est plus petit
                    else
                        Just minReste            -- minReste est plus petit
```

**Utilisation :**
```elm
minimum [3, 1, 4, 1, 5]
--> Just 1

minimum [42]
--> Just 42

minimum []
--> Nothing
```

**Trace d'exÃ©cution :**
```elm
minimum [3, 1, 4]
= case minimum [1, 4] of          -- 3 vs min([1,4])
    Just 1 -> if 3 < 1 then Just 3 else Just 1
= Just 1

minimum [5]
= case minimum [] of              -- 5 vs rien
    Nothing -> Just 5
= Just 5
```

---

## ğŸ’ª Exercices (Ã€ Faire)

### Exercice 1 : `elementA`
Ã‰cris une fonction qui retourne l'Ã©lÃ©ment Ã  la position `n` (commence Ã  0).

```elm
elementA : Int -> Liste a -> Maybe a

-- Exemples attendus
elementA 0 [1, 2, 3]  --> Just 1
elementA 2 [1, 2, 3]  --> Just 3
elementA 5 [1, 2, 3]  --> Nothing
elementA -1 [1, 2, 3] --> Nothing
```

**Indice :** Utilise `drop` et `premier`.

### Exercice 2 : `maximum`
Ã‰cris une fonction qui retourne le plus grand Ã©lÃ©ment.

```elm
maximum : Liste comparable -> Maybe comparable

-- Exemples attendus
maximum [3, 1, 4, 1, 5]  --> Just 5
maximum []               --> Nothing
```

**Indice :** Similaire Ã  `minimum`, mais avec `>` au lieu de `<`.

### Exercice 3 : `trouver`
Ã‰cris une fonction qui retourne le premier Ã©lÃ©ment satisfaisant un prÃ©dicat.

```elm
trouver : (a -> Bool) -> Liste a -> Maybe a

-- Exemples attendus
trouver (\x -> x > 3) [1, 2, 3, 4, 5]  --> Just 4
trouver (\x -> x > 10) [1, 2, 3]       --> Nothing
```

---

## ğŸ¯ Pourquoi Maybe est Important ?

### 1. SÃ©curitÃ© Ã  la Compilation

```elm
-- âŒ Impossible en Elm
x = premier []
y = x + 1  -- Erreur de compilation !

-- âœ… Elm force Ã  gÃ©rer le cas Nothing
x = premier []
y = case x of
    Just n -> n + 1
    Nothing -> 0
```

**Pas de crash Ã  l'exÃ©cution !** ğŸ›¡ï¸

### 2. Code Explicite

```elm
-- La signature dit tout
dernierElement : Liste a -> Maybe a
--                          â†‘
--                          "Peut Ã©chouer !"

-- vs en Python
def last_element(lst):  # Peut retourner None... ou crasher ?
    ...
```

### 3. Forcer Ã  Penser aux Cas d'Erreur

```elm
-- Tu DOIS gÃ©rer Nothing
case premier maListe of
    Nothing -> ...  -- ObligÃ© de penser Ã  ce cas
    Just x -> ...
```

---

## ğŸ“Š Maybe vs Autres Approches

| Approche | ProblÃ¨me | Elm avec Maybe |
|----------|----------|----------------|
| Valeur spÃ©ciale (-1, "") | AmbiguÃ« | Explicite avec type |
| Exception | Invisible, peut crasher | Visible dans signature |
| `null`/`None` | Pas vÃ©rifiÃ© Ã  la compilation | VÃ©rifiÃ© ! |
| **Maybe** | **Aucun** | **âœ… Parfait** |

---

## ğŸ”„ Pattern RÃ©current

### Le SchÃ©ma Maybe

```elm
maFonction : EntrÃ©ePeut-ÃŠtreVide -> Maybe RÃ©sultat
maFonction entree =
    case entree of
        CasVide -> Nothing                    -- Ã‰chec
        CasNonVide donnÃ©es -> Just rÃ©sultat   -- SuccÃ¨s
```

**Exemples :**

- Liste vide â†’ `Nothing`
- Division par zÃ©ro â†’ `Nothing`
- ClÃ© inexistante dans dictionnaire â†’ `Nothing`
- Parsing Ã©chouÃ© â†’ `Nothing`

---

## âœ… RÃ©sumÃ©

### Qu'est-ce que Maybe ?

```elm
type Maybe a = Nothing | Just a
```

- **`Nothing`** : Absence de valeur (Ã©chec, vide, erreur)
- **`Just valeur`** : PrÃ©sence d'une valeur

### Quand Utiliser Maybe ?

Utilise `Maybe a` pour le type de retour d'une fonction quand :

- âœ… La fonction peut Ã©chouer
- âœ… Il peut ne pas y avoir de rÃ©sultat
- âœ… L'entrÃ©e peut Ãªtre vide

### Fonctions ClÃ©s

```elm
-- Valeur par dÃ©faut
Maybe.withDefault : a -> Maybe a -> a

-- Transformer
Maybe.map : (a -> b) -> Maybe a -> Maybe b

-- ChaÃ®ner
Maybe.andThen : (a -> Maybe b) -> Maybe a -> Maybe b
```

### Le Pattern

```elm
case monMaybe of
    Nothing -> -- GÃ©rer l'absence
    Just valeur -> -- Utiliser la valeur
```

---

## ğŸ’¡ Conseil Final

**Si ta fonction peut "Ã©chouer" ou "ne rien retourner", utilise `Maybe` !**

```elm
-- âœ… Bon
premier : Liste a -> Maybe a

-- âŒ Mauvais (impossible de reprÃ©senter l'Ã©chec)
premier : Liste a -> a  -- Et si la liste est vide ???
```

**Maybe = SÃ©curitÃ© + ClartÃ© + Pas de surprise !** ğŸ¯

---

## ğŸ“š Pour Aller Plus Loin

Une fois que tu maÃ®trises `Maybe`, tu peux dÃ©couvrir `Result` : Pour les erreurs avec message.

Mais pour l'instant, **`Maybe` est dÃ©jÃ  trÃ¨s puissant !** ğŸ’ª
