# 1. Principes de base

## Note d'intention

**Elm N'Est Qu'un Pr√©texte**

**Voici la v√©rit√© :** Ce cours ne vous enseigne pas vraiment Elm. Il vous enseigne **comment penser les probl√®mes**.



### Ce Que Vous Apprenez R√©ellement

Quand vous √©crivez :
```elm
taille : Liste a -> Int
taille lst =
    case lst of
        Vide -> 0
        Cons _ queue -> 1 + taille queue
```

Vous n'apprenez pas juste √† calculer la taille d'une liste. Vous apprenez :

1. **D√©composer un probl√®me** en cas plus simples
2. **Identifier les cas de base** (quand arr√™ter)
3. **Faire confiance √† la r√©cursion** (le lutin qui g√®re le reste)
4. **Raisonner par induction** (math√©matiques !)
5. **Penser en termes de transformations** plut√¥t que de mutations

**Ces comp√©tences sont universelles.**

**Surprise!** Vous savez d√©j√† programmer en OCaml! (et pas que)

```ocaml
type 'a liste = Vide | Cons of 'a * 'a liste

let rec taille (lst : 'a liste) : int =
    match lst with
    | Vide -> 0
    | Cons (_, queue) -> 1 + taille queue
``` 



---

## 0. Syntaxe de base

Je ne m'√©tendrai pas sur l'indentation qui est n√©cessaire comme en python, contentez vous de faire comme je fais.

## Appeler des Fonctions en Elm

### Syntaxe de base (PAS de parenth√®ses !)

```elm
-- ‚ùå PAS comme en Python
fonction(arg1, arg2)

-- ‚úÖ En Elm : juste des espaces
fonction arg1 arg2
```

### Exemples concrets

```elm
-- Python: max(5, 3)
-- Elm:
max 5 3

-- Python: range(0, 10)
-- Elm:
range2 0 10

-- Python: taille(liste)
-- Elm:
taille lst
```

### R√¥le des Parenth√®ses

**Les parenth√®ses servent √† GROUPER, pas √† appeler !**

```elm
-- Si l'argument est une expression complexe
taille (Cons 1 Vide)
--     ‚Üë            ‚Üë
--     Sans ces parenth√®ses, Elm lirait: taille Cons 1 Vide (3 arguments!)

-- Appels imbriqu√©s
somme (take 3 lst)
--    ‚Üë          ‚Üë
--    Groupe "take 3 lst" comme UN argument

-- Plusieurs niveaux
Cons tete (take (n - 1) queue)
--        ‚Üë                  ‚Üë
--        Sans √ßa: Cons tete take (n - 1) queue (Cons avec 4 arguments: erreur)
-- pareil pour le (n - 1)
```


### R√®gle Simple

- **Pas de parenth√®ses** = appel direct : `fonction arg`
- **Avec parenth√®ses** = grouper une expression : `fonction (expression)`


**Mn√©motechnique :** Parenth√®ses = calculer d'abord, puis passer le r√©sultat.

---

## Cr√©er des Fonctions en Elm

### Structure Compl√®te

```elm
-- 1. Signature de type (optionnelle mais recommand√©e)
doublerValeur : Int -> Int
--  ‚Üë           ‚Üë      ‚Üë
--  nom      entr√©e  sortie

-- 2. D√©finition
doublerValeur n = n * 2
--  ‚Üë         ‚Üë   ‚Üë
--  nom    param  corps
```

---

## üîç La Signature de Type

### Format

```elm
nomFonction : Type1 -> Type2 -> ... -> TypeRetour
```

**Lecture :** La fonction prend des param√®tres de `Type1`, `Type2`, etc., et retourne un `TypeRetour`.

### Exemples Simples

```elm
-- Fonction sans param√®tre (constante)
reponse : Int
reponse = 42

-- Fonction √† 1 param√®tre
doublerValeur : Int -> Int
doublerValeur n = n * 2

-- Fonction √† 2 param√®tres
additionner : Int -> Int -> Int
additionner x y = x + y

-- Fonction √† 3 param√®tres
calculer : Int -> Int -> Int -> Int
calculer a b c = a + b * c
```


## 1. Types de Donn√©es Personnalis√©s

### D√©finir un type personnalis√©

```elm
type Liste a            -- 'a' est un type g√©n√©rique (Int, String, Bool, etc.)
    = Vide              -- Premier cas : liste vide
    | Cons a (Liste a)  -- Deuxi√®me cas : t√™te + queue
```

**Lecture :** Une Liste de `a` est **SOIT** Vide **SOIT** Construite avec un √©l√©ment de type `a` et une autre Liste.

### Exemples

```elm
-- Liste d'entiers : [42, 5, 4]
Cons 42 (Cons 5 (Cons 4 Vide))

-- Liste de bool√©ens : [True, False]
Cons True (Cons False Vide)

-- Liste vide
Vide
```

---

## 2. Pattern Matching avec `case`

### Syntaxe de base

```elm
case expression of
    motif1 -> r√©sultat1
    motif2 -> r√©sultat2
    _      -> r√©sultatParD√©faut
```

### Exemple simple

```elm
taille : Liste a -> Int
taille lst =
    case lst of
        Vide -> 0                           -- Cas 1 : liste vide
        Cons tete queue -> 1 + taille queue -- Cas 2 : d√©construit la liste
```

**D√©composition :**
```
Cons 42 (Cons 5 Vide)
  ‚Üì       ‚Üì
 tete    queue

tete = 42
queue = Cons 5 Vide
```

### Pattern matching sur un tuple

```elm
case (lst1, lst2) of
    (Vide, Vide) -> ...    -- Les deux sont vides
    (Vide, _)    -> ...    -- Premi√®re vide, deuxi√®me peu importe
    (_, Vide)    -> ...    -- Deuxi√®me vide, premi√®re peu importe
    (Cons t1 q1, Cons t2 q2) -> ...  -- Les deux non-vides
```

**Le symbole `_`** = "je m'en fiche de cette valeur"

---

## 3. R√©cursivit√© : Penser comme un Lutin

### La M√©thode du Lutin

**Ne JAMAIS penser √† TOUTE la liste !** Pense seulement au premier √©l√©ment.

#### √âtape 1 : Identifier le(s) CAS DE BASE

Le cas de base, c'est quand on peut r√©pondre **imm√©diatement** sans r√©cursion.

```elm
taille : Liste a -> Int
taille lst =
    case lst of
        Vide -> 0  -- ‚úÖ CAS DE BASE : liste vide = 0
        Cons _ queue -> ...
```

#### √âtape 2 : Le Cas R√©cursif

"Je suis un lutin, je ne traite QUE le premier √©l√©ment, puis je d√©l√®gue le reste √† un autre lutin."

```elm
somme : Liste Int -> Int
somme lst =
    case lst of
        Vide -> 0                      -- CAS DE BASE
        Cons tete queue -> 
            tete + somme queue         -- Je traite tete, je d√©l√®gue queue
            --‚Üë          ‚Üë
            -- moi    autre lutin
```

**Visualisation :**
```
somme [42, 5, 4]
= 42 + somme [5, 4]
     = 5 + somme [4]
          = 4 + somme []
               = 0

= 42 + 5 + 4 + 0
= 51
```

---

## 4. Conditions avec `if-then-else`

‚ö†Ô∏è Attention, contrairement √† python, les conditions repr√©sentent une valeur renvoy√©e

### Syntaxe

```elm
if condition then
    r√©sultatSiVrai
else
    r√©sultatSiFaux
```

**‚ö†Ô∏è OBLIGATOIRE : Toujours un `else` en Elm !**

### Exemples

```elm
-- Test d'√©galit√©
if tete == e then
    ...
else
    ...

-- Test num√©rique
if n > 0 then
    Cons tete (take (n - 1) queue)
else
    Vide

-- Modulo (reste de division)
if modBy 2 x == 0 then
    "pair"
else
    "impair"
```

---

## 5. Op√©rateurs Bool√©ens

```elm
-- ET logique
True && True   --> True
True && False  --> False

-- OU logique
True || False  --> True
False || False --> False

-- √âgalit√©
42 == 42  --> True
42 == 5   --> False

-- Diff√©rence
42 /= 5   --> True

-- Comparaisons
5 > 3   --> True
5 >= 5  --> True
5 < 10  --> True
```

---

## 6. Strat√©gies de R√©solution

### Strat√©gie 1 : Fonction de Lecture (compte, contient, etc.)

**Question :** Que faire de la t√™te ? Que faire de la queue ?

```elm
compte : a -> Liste a -> Int
compte e lst =
    case lst of
        Vide -> 0  -- CAS DE BASE
        Cons tete queue ->
            if tete == e then
                1 + compte e queue  -- J'ai trouv√© e, j'ajoute 1 au reste
            else
                compte e queue      -- Pas trouv√©, je demande juste le reste
```

### Strat√©gie 2 : Pr√©dicat (renvoie Bool)

**Question :** Quelle condition casse la promesse du pr√©dicat ?

**Cette mani√®re de faire n'est pas bonne (bien que correcte), elle montre que vous n'avez pas encore bien assimil√© le calcul bool√©en**
```elm
-- "Tous vrais" : un seul False casse la promesse
tousVrais : Liste Bool -> Bool
tousVrais lst =
    case lst of
        Vide -> True  -- Promesse non viol√©e (rien √† v√©rifier)
        Cons tete queue ->
            if tete == False then
                False  -- Promesse cass√©e !
            else
                tousVrais queue  -- Continue de v√©rifier
```
**Cette mani√®re de faire montre que vous avez assimil√© le calcul bool√©en.**

```elm
-- Ici la promesse est viol√©e quand d√®s que tete est False
tousVrais : Liste Bool -> Bool
tousVrais lst =
    case lst of
        Vide -> True
        Cons tete queue -> tete && tousVrais queue
```

**Note:** Les op√©rateurs bool√©ens sont dits "lazy". Lors de l'√©valuation de `x && y`, si x est False, alors y ne sera pas √©valu√©. Pareil pour `x||y`. si x est vrai, y ne sera pas √©valu√©.

### Strat√©gie 3 : Fonction de Cr√©ation (pairs, dupliquer, etc.)

**Question :** Dois-je inclure la t√™te ? Comment construire avec Cons ?

```elm
pairs : Liste Int -> Liste Int
pairs lst =
    case lst of
        Vide -> Vide  -- CAS DE BASE
        Cons tete queue ->
            if modBy 2 tete == 0 then
                Cons tete (pairs queue)  -- T√™te paire : je la garde  et je demande le reste
            else
                pairs queue              -- T√™te impaire : je la jette, je demande juste le reste
```

---

## 7. Pattern Matching Avanc√©

### Cas avec plusieurs niveaux

```elm
supprimerFin : Liste a -> Liste a
supprimerFin lst =
    case lst of
        Vide -> Vide              -- Liste vide
        Cons _ Vide -> Vide       -- Un seul √©l√©ment, on renvoie Vide
        Cons t q -> Cons t (supprimerFin q)  -- Plusieurs √©l√©ments
```

### Tuple de listes

```elm
egales : Liste a -> Liste a -> Liste a
egales lst1 lst2 =
    case (lst1, lst2) of
        (Vide, Vide) -> True         -- Les deux sont vides
        (Vide, _) -> False           -- Premi√®re vide, deuxi√®me non vide (sinon on serait dans le cas 1)
        (_, Vide) -> False           -- Deuxi√®me vide : premi√®re non vide (idem)
        (Cons t1 q1, Cons t2 q2) ->  -- Cas r√©cursif
                (t1==t2) && egales t1 t2  
```

---


## 9. Erreurs Courantes

### ‚ùå Oublier le cas de base

```elm
-- ERREUR : boucle infinie !
somme lst =
    case lst of
        Cons t q -> t + somme q  -- Et si lst est Vide ???
```

### ‚ùå Oublier le `else`

```elm
-- ERREUR : else obligatoire en Elm !
if n > 0 then
    n
-- Manque else !
```

### ‚ùå Confondre `=` et `==`

```elm
x = 5      -- D√©finition (cr√©er une variable)
x == 5     -- Comparaison (tester l'√©galit√©)
```

### ‚ùå Mauvais pattern matching

```elm
-- ERREUR : les cas ne couvrent pas tout
case lst of
    Vide -> 0
    -- Manque le cas Cons !
```

---

## 10. Vocabulaire Elm

| Terme | Signification |
|-------|---------------|
| `type` | D√©finir un nouveau type |
| `case ... of` | Pattern matching |
| `let ... in` | Variables locales |
| `->` | "devient" ou "retourne" |
| `_` | "je m'en fous" (wildcard) |
| `comparable` | Type qui peut √™tre compar√© (<, >, ==) |
| `number` | Type num√©rique (Int ou Float) |

---

## 11. Comment Aborder les Exercices

### D√©marche pour `contient`

**Objectif :** V√©rifier si un √©l√©ment `e` est dans la liste.

**Questions √† se poser :**

- Cas de base : Si la liste est vide, est-ce que `e` peut √™tre dedans ?
- Cas r√©cursif : Si la t√™te est √©gale √† `e`, qu'est-ce que je retourne ?
- Si la t√™te n'est pas `e`, que dois-je faire avec la queue ?

**Astuce :** Utilise l'op√©rateur OU `||` pour combiner les conditions.

### D√©marche pour `ajouterFin`

**Objectif :** Ajouter un √©l√©ment √† la fin de la liste.

**Questions √† se poser :**

- Cas de base : Si la liste est vide, comment cr√©er une liste avec juste `e` ?
- Cas r√©cursif : Je garde la t√™te, mais que dois-je faire avec la queue ?

**Trace mentale :**
```
ajouterFin 9 [1, 2, 3]
= Je garde 1, et j'ajoute 9 √† la fin de [2, 3]
  = Je garde 2, et j'ajoute 9 √† la fin de [3]
    = Je garde 3, et j'ajoute 9 √† la fin de []
      = Cas de base : cr√©er [9]
```

### D√©marche pour `range2`

**Objectif :** Cr√©er la liste [a, a+1, a+2, ..., b-1]

**Questions √† se poser :**

- Cas de base : Quand est-ce que je dois arr√™ter ? (quand a >= b)
- Cas r√©cursif : Je mets `a` en t√™te, puis quoi en queue ?

**R√©flexion :** C'est similaire √† une boucle `for i in range(a, b)` en Python.

---

## 12. M√©thode de Travail

### Pour chaque fonction :

1. **Identifier les cas de base**
   - Que faire si `lst` est `Vide` ?
   - Y a-t-il d'autres cas simples ? (liste √† 1 √©l√©ment, n <= 0, etc.)

2. **D√©construire avec pattern matching**
   ```elm
   case lst of
       Vide -> ...
       Cons tete queue -> ...
   ```

3. **Penser comme un lutin**
   - Que dois-je faire avec `tete` ?
   - Que dois-je faire avec `queue` ?
   - Comment combiner les deux ?

4. **V√©rifier la logique**
   - Est-ce que mon cas de base est correct ?
   - Est-ce que je me rapproche du cas de base √† chaque r√©cursion ?

---

## 13. Tests dans Elm

### Utiliser les exemples fournis

```elm
-- Exemple dans le fichier
-- taille lstEx1 --> 3

-- Pour tester dans elm repl :
$ elm repl
> import Liste exposing (..)
> taille lstEx1
3 : Int
```

### Debug.todo

```elm
-- Pendant le d√©veloppement
maFonction x =
    Debug.todo "√Ä impl√©menter"

-- Remplacer progressivement les Debug.todo par du vrai code
```

---

## 14. Astuces de D√©bogage

### Afficher des valeurs

```elm
-- Pendant le d√©veloppement
maFonction x =
    let
        _ = Debug.log "x vaut" x  -- Affiche dans la console
    in
    ...
```

### Simplifier le probl√®me

```elm
-- Au lieu de r√©soudre tout de suite [1,2,3,4,5]
-- Teste d'abord avec :
-- []
-- [1]
-- [1, 2]
```

### √âcrire la trace

```
somme [42, 5]
= 42 + somme [5]
     = 5 + somme []
          = 0
= 42 + 5 + 0
= 47
```

---

## 15. Complexit√© (Pour Information)

| Op√©ration | Complexit√© |
|-----------|------------|
| `Cons x lst` | O(1) - instantan√© |
| `ajouterFin x lst` | O(n) - doit tout parcourir |
| `taille lst` | O(n) - compte tous les √©l√©ments |
| `concat lst1 lst2` | O(n) o√π n = taille de lst1 |

**R√®gle :** Pr√©f√®re construire avec `Cons` plut√¥t qu'avec `ajouterFin`.

---

## üéØ Checklist Avant de Coder

- [ ] J'ai identifi√© le(s) cas de base
- [ ] Je sais quoi faire avec `Vide`
- [ ] Je sais quoi faire avec `tete`
- [ ] Je sais quoi faire avec `queue`
- [ ] Je comprends comment combiner t√™te et r√©sultat r√©cursif
- [ ] J'ai v√©rifi√© que je me rapproche du cas de base

---

## üí° Conseils Finaux

1. **Ne pense JAMAIS √† toute la liste** - juste au premier √©l√©ment
2. **Fais confiance √† la r√©cursion** - elle g√®re le reste
3. **Teste sur des petits exemples** - [], [1], [1,2]
4. **Lis les exemples fournis** - ils t'aident √† comprendre
5. **Commence par les fonctions simples** - taille, somme, contient
6. **Utilise les fonctions d√©j√† √©crites** - range pour range2, etc.

---

## üöÄ Tu es Pr√™t !

Avec ces concepts, tu peux r√©soudre TOUS les exercices du fichier. N'oublie pas :

- Pattern matching pour d√©construire
- R√©cursion pour traiter
- Cas de base pour arr√™ter

