# 1. Principes de base


## ğŸ¯ Objectif

Apprendre Ã  rÃ©soudre des ProblÃ¨mes simples en apprenant certaines bases de la programmation fonctionnelle.

---

## 0. Syntaxe de base

Je ne m'Ã©tendrai pas sur l'indentation qui est nÃ©cessaire comme en python, contentez vous de faire comme je fais.

## Appeler des Fonctions en Elm

### Syntaxe de base (PAS de parenthÃ¨ses !)

```elm
-- âŒ PAS comme en Python
fonction(arg1, arg2)

-- âœ… En Elm : juste des espaces
fonction arg1 arg2
```

### Exemples concrets

```elm
-- Python: max(5, 3)
-- Elm:
max 5 3

-- Python: range(0, 10)
-- Elm:
range2 0 10

-- Python: taille(liste)
-- Elm:
taille lst
```

### RÃ´le des ParenthÃ¨ses

**Les parenthÃ¨ses servent Ã  GROUPER, pas Ã  appeler !**

```elm
-- Si l'argument est une expression complexe
taille (Cons 1 Vide)
--     â†‘            â†‘
--     Sans ces parenthÃ¨ses, Elm lirait: taille Cons 1 Vide (3 arguments!)

-- Appels imbriquÃ©s
somme (take 3 lst)
--    â†‘          â†‘
--    Groupe "take 3 lst" comme UN argument

-- Plusieurs niveaux
Cons tete (take (n - 1) queue)
--        â†‘                  â†‘
--        Sans Ã§a: Cons tete take (n - 1) queue (Cons avec 4 arguments: erreur)
-- pareil pour le (n - 1)
```


### RÃ¨gle Simple

- **Pas de parenthÃ¨ses** = appel direct : `fonction arg`
- **Avec parenthÃ¨ses** = grouper une expression : `fonction (expression)`


**MnÃ©motechnique :** ParenthÃ¨ses = calculer d'abord, puis passer le rÃ©sultat.

---

## CrÃ©er des Fonctions en Elm

### Structure ComplÃ¨te

```elm
-- 1. Signature de type (optionnelle mais recommandÃ©e)
doublerValeur : Int -> Int
--  â†‘           â†‘      â†‘
--  nom      entrÃ©e  sortie

-- 2. DÃ©finition
doublerValeur n = n * 2
--  â†‘         â†‘   â†‘
--  nom    param  corps
```

---

## ğŸ” La Signature de Type

### Format

```elm
nomFonction : Type1 -> Type2 -> ... -> TypeRetour
```

**Lecture :** La fonction prend des paramÃ¨tres de `Type1`, `Type2`, etc., et retourne un `TypeRetour`.

### Exemples Simples

```elm
-- Fonction sans paramÃ¨tre (constante)
reponse : Int
reponse = 42

-- Fonction Ã  1 paramÃ¨tre
doublerValeur : Int -> Int
doublerValeur n = n * 2

-- Fonction Ã  2 paramÃ¨tres
additionner : Int -> Int -> Int
additionner x y = x + y

-- Fonction Ã  3 paramÃ¨tres
calculer : Int -> Int -> Int -> Int
calculer a b c = a + b * c
```


## 1. Types de DonnÃ©es PersonnalisÃ©s

### DÃ©finir un type personnalisÃ©

```elm
type Liste a            -- 'a' est un type gÃ©nÃ©rique (Int, String, Bool, etc.)
    = Vide              -- Premier cas : liste vide
    | Cons a (Liste a)  -- DeuxiÃ¨me cas : tÃªte + queue
```

**Lecture :** Une Liste de `a` est **SOIT** Vide **SOIT** Construite avec un Ã©lÃ©ment de type `a` et une autre Liste.

### Exemples

```elm
-- Liste d'entiers : [42, 5, 4]
Cons 42 (Cons 5 (Cons 4 Vide))

-- Liste de boolÃ©ens : [True, False]
Cons True (Cons False Vide)

-- Liste vide
Vide
```

---

## 2. Pattern Matching avec `case`

### Syntaxe de base

```elm
case expression of
    motif1 -> rÃ©sultat1
    motif2 -> rÃ©sultat2
    _      -> rÃ©sultatParDÃ©faut
```

### Exemple simple

```elm
taille : Liste a -> Int
taille lst =
    case lst of
        Vide -> 0                           -- Cas 1 : liste vide
        Cons tete queue -> 1 + taille queue -- Cas 2 : dÃ©construit la liste
```

**DÃ©composition :**
```
Cons 42 (Cons 5 Vide)
  â†“       â†“
 tete    queue

tete = 42
queue = Cons 5 Vide
```

### Pattern matching sur un tuple

```elm
case (lst1, lst2) of
    (Vide, Vide) -> ...    -- Les deux sont vides
    (Vide, _)    -> ...    -- PremiÃ¨re vide, deuxiÃ¨me peu importe
    (_, Vide)    -> ...    -- DeuxiÃ¨me vide, premiÃ¨re peu importe
    (Cons t1 q1, Cons t2 q2) -> ...  -- Les deux non-vides
```

**Le symbole `_`** = "je m'en fiche de cette valeur"

---

## 3. RÃ©cursivitÃ© : Penser comme un Lutin

### La MÃ©thode du Lutin

**Ne JAMAIS penser Ã  TOUTE la liste !** Pense seulement au premier Ã©lÃ©ment.

#### Ã‰tape 1 : Identifier le(s) CAS DE BASE

Le cas de base, c'est quand on peut rÃ©pondre **immÃ©diatement** sans rÃ©cursion.

```elm
taille : Liste a -> Int
taille lst =
    case lst of
        Vide -> 0  -- âœ… CAS DE BASE : liste vide = 0
        Cons _ queue -> ...
```

#### Ã‰tape 2 : Le Cas RÃ©cursif

"Je suis un lutin, je ne traite QUE le premier Ã©lÃ©ment, puis je dÃ©lÃ¨gue le reste Ã  un autre lutin."

```elm
somme : Liste Int -> Int
somme lst =
    case lst of
        Vide -> 0                      -- CAS DE BASE
        Cons tete queue -> 
            tete + somme queue         -- Je traite tete, je dÃ©lÃ¨gue queue
            --â†‘          â†‘
            -- moi    autre lutin
```

**Visualisation :**
```
somme [42, 5, 4]
= 42 + somme [5, 4]
     = 5 + somme [4]
          = 4 + somme []
               = 0

= 42 + 5 + 4 + 0
= 51
```

---

## 4. Conditions avec `if-then-else`

âš ï¸ Attention, contrairement Ã  python, les conditions reprÃ©sentent une valeur renvoyÃ©e

### Syntaxe

```elm
if condition then
    rÃ©sultatSiVrai
else
    rÃ©sultatSiFaux
```

**âš ï¸ OBLIGATOIRE : Toujours un `else` en Elm !**

### Exemples

```elm
-- Test d'Ã©galitÃ©
if tete == e then
    ...
else
    ...

-- Test numÃ©rique
if n > 0 then
    Cons tete (take (n - 1) queue)
else
    Vide

-- Modulo (reste de division)
if modBy 2 x == 0 then
    "pair"
else
    "impair"
```

---

## 5. OpÃ©rateurs BoolÃ©ens

```elm
-- ET logique
True && True   --> True
True && False  --> False

-- OU logique
True || False  --> True
False || False --> False

-- Ã‰galitÃ©
42 == 42  --> True
42 == 5   --> False

-- DiffÃ©rence
42 /= 5   --> True

-- Comparaisons
5 > 3   --> True
5 >= 5  --> True
5 < 10  --> True
```

---

## 6. StratÃ©gies de RÃ©solution

### StratÃ©gie 1 : Fonction de Lecture (compte, contient, etc.)

**Question :** Que faire de la tÃªte ? Que faire de la queue ?

```elm
compte : a -> Liste a -> Int
compte e lst =
    case lst of
        Vide -> 0  -- CAS DE BASE
        Cons tete queue ->
            if tete == e then
                1 + compte e queue  -- J'ai trouvÃ© e, j'ajoute 1 au reste
            else
                compte e queue      -- Pas trouvÃ©, je demande juste le reste
```

### StratÃ©gie 2 : PrÃ©dicat (renvoie Bool)

**Question :** Quelle condition casse la promesse du prÃ©dicat ?

**Cette maniÃ¨re de faire n'est pas bonne (bien que correcte), elle montre que vous n'avez pas encore bien assimilÃ© le calcul boolÃ©en**
```elm
-- "Tous vrais" : un seul False casse la promesse
tousVrais : Liste Bool -> Bool
tousVrais lst =
    case lst of
        Vide -> True  -- Promesse non violÃ©e (rien Ã  vÃ©rifier)
        Cons tete queue ->
            if tete == False then
                False  -- Promesse cassÃ©e !
            else
                tousVrais queue  -- Continue de vÃ©rifier
```
**Cette maniÃ¨re de faire montre que vous avez assimilÃ© le calcul boolÃ©en.**

```elm
-- Ici la promesse est violÃ©e quand dÃ¨s que tete est False
tousVrais : Liste Bool -> Bool
tousVrais lst =
    case lst of
        Vide -> True
        Cons tete queue -> tete && tousVrais queue
```

**Note:** Les opÃ©rateurs boolÃ©ens sont dits "lazy". Lors de l'Ã©valuation de `x && y`, si x est False, alors y ne sera pas Ã©valuÃ©. Pareil pour `x||y`. si x est vrai, y ne sera pas Ã©valuÃ©.

### StratÃ©gie 3 : Fonction de CrÃ©ation (pairs, dupliquer, etc.)

**Question :** Dois-je inclure la tÃªte ? Comment construire avec Cons ?

```elm
pairs : Liste Int -> Liste Int
pairs lst =
    case lst of
        Vide -> Vide  -- CAS DE BASE
        Cons tete queue ->
            if modBy 2 tete == 0 then
                Cons tete (pairs queue)  -- TÃªte paire : je la garde  et je demande le reste
            else
                pairs queue              -- TÃªte impaire : je la jette, je demande juste le reste
```

---

## 7. Pattern Matching AvancÃ©

### Cas avec plusieurs niveaux

```elm
supprimerFin : Liste a -> Liste a
supprimerFin lst =
    case lst of
        Vide -> Vide              -- Liste vide
        Cons _ Vide -> Vide       -- Un seul Ã©lÃ©ment, on renvoie Vide
        Cons t q -> Cons t (supprimerFin q)  -- Plusieurs Ã©lÃ©ments
```

### Tuple de listes

```elm
egales : Liste a -> Liste a -> Liste a
egales lst1 lst2 =
    case (lst1, lst2) of
        (Vide, Vide) -> True         -- Les deux sont vides
        (Vide, _) -> False           -- PremiÃ¨re vide, deuxiÃ¨me non vide (sinon on serait dans le cas 1)
        (_, Vide) -> False           -- DeuxiÃ¨me vide : premiÃ¨re non vide (idem)
        (Cons t1 q1, Cons t2 q2) ->  -- Cas rÃ©cursif
                (t1==t2) && egales t1 t2  
```

---


## 9. Erreurs Courantes

### âŒ Oublier le cas de base

```elm
-- ERREUR : boucle infinie !
somme lst =
    case lst of
        Cons t q -> t + somme q  -- Et si lst est Vide ???
```

### âŒ Oublier le `else`

```elm
-- ERREUR : else obligatoire en Elm !
if n > 0 then
    n
-- Manque else !
```

### âŒ Confondre `=` et `==`

```elm
x = 5      -- DÃ©finition (crÃ©er une variable)
x == 5     -- Comparaison (tester l'Ã©galitÃ©)
```

### âŒ Mauvais pattern matching

```elm
-- ERREUR : les cas ne couvrent pas tout
case lst of
    Vide -> 0
    -- Manque le cas Cons !
```

---

## 10. Vocabulaire Elm

| Terme | Signification |
|-------|---------------|
| `type` | DÃ©finir un nouveau type |
| `case ... of` | Pattern matching |
| `let ... in` | Variables locales |
| `->` | "devient" ou "retourne" |
| `\|` | "ou" dans une dÃ©finition de type |
| `_` | "je m'en fous" (wildcard) |
| `comparable` | Type qui peut Ãªtre comparÃ© (<, >, ==) |
| `number` | Type numÃ©rique (Int ou Float) |

---

## 11. Comment Aborder les Exercices

### DÃ©marche pour `contient`

**Objectif :** VÃ©rifier si un Ã©lÃ©ment `e` est dans la liste.

**Questions Ã  se poser :**
- Cas de base : Si la liste est vide, est-ce que `e` peut Ãªtre dedans ?
- Cas rÃ©cursif : Si la tÃªte est Ã©gale Ã  `e`, qu'est-ce que je retourne ?
- Si la tÃªte n'est pas `e`, que dois-je faire avec la queue ?

**Astuce :** Utilise l'opÃ©rateur `||` pour combiner les conditions.

### DÃ©marche pour `ajouterFin`

**Objectif :** Ajouter un Ã©lÃ©ment Ã  la fin de la liste.

**Questions Ã  se poser :**
- Cas de base : Si la liste est vide, comment crÃ©er une liste avec juste `e` ?
- Cas rÃ©cursif : Je garde la tÃªte, mais que dois-je faire avec la queue ?

**Trace mentale :**
```
ajouterFin 9 [1, 2, 3]
= Je garde 1, et j'ajoute 9 Ã  la fin de [2, 3]
  = Je garde 2, et j'ajoute 9 Ã  la fin de [3]
    = Je garde 3, et j'ajoute 9 Ã  la fin de []
      = Cas de base : crÃ©er [9]
```

### DÃ©marche pour `range2`

**Objectif :** CrÃ©er la liste [a, a+1, a+2, ..., b-1]

**Questions Ã  se poser :**
- Cas de base : Quand est-ce que je dois arrÃªter ? (quand a >= b)
- Cas rÃ©cursif : Je mets `a` en tÃªte, puis quoi en queue ?

**RÃ©flexion :** C'est similaire Ã  une boucle `for i in range(a, b)` en Python.

---

## 12. MÃ©thode de Travail

### Pour chaque fonction :

1. **Identifier les cas de base**
   - Que faire si `lst` est `Vide` ?
   - Y a-t-il d'autres cas simples ? (liste Ã  1 Ã©lÃ©ment, n <= 0, etc.)

2. **DÃ©construire avec pattern matching**
   ```elm
   case lst of
       Vide -> ...
       Cons tete queue -> ...
   ```

3. **Penser comme un lutin**
   - Que dois-je faire avec `tete` ?
   - Que dois-je faire avec `queue` ?
   - Comment combiner les deux ?

4. **VÃ©rifier la logique**
   - Est-ce que mon cas de base est correct ?
   - Est-ce que je me rapproche du cas de base Ã  chaque rÃ©cursion ?

---

## 13. Tests dans Elm

### Utiliser les exemples fournis

```elm
-- Exemple dans le fichier
-- taille lstEx1 --> 3

-- Pour tester dans elm repl :
$ elm repl
> import Liste exposing (..)
> taille lstEx1
3 : Int
```

### Debug.todo

```elm
-- Pendant le dÃ©veloppement
maFonction x =
    Debug.todo "Ã€ implÃ©menter"

-- Remplacer progressivement les Debug.todo par du vrai code
```

---

## 14. Astuces de DÃ©bogage

### Afficher des valeurs

```elm
-- Pendant le dÃ©veloppement
maFonction x =
    let
        _ = Debug.log "x vaut" x  -- Affiche dans la console
    in
    ...
```

### Simplifier le problÃ¨me

```elm
-- Au lieu de rÃ©soudre tout de suite [1,2,3,4,5]
-- Teste d'abord avec :
-- []
-- [1]
-- [1, 2]
```

### Ã‰crire la trace

```
somme [42, 5]
= 42 + somme [5]
     = 5 + somme []
          = 0
= 42 + 5 + 0
= 47
```

---

## 15. ComplexitÃ© (Pour Information)

| OpÃ©ration | ComplexitÃ© |
|-----------|------------|
| `Cons x lst` | O(1) - instantanÃ© |
| `ajouterFin x lst` | O(n) - doit tout parcourir |
| `taille lst` | O(n) - compte tous les Ã©lÃ©ments |
| `concat lst1 lst2` | O(n) oÃ¹ n = taille de lst1 |

**RÃ¨gle :** PrÃ©fÃ¨re construire avec `Cons` plutÃ´t qu'avec `ajouterFin`.

---

## ğŸ¯ Checklist Avant de Coder

- [ ] J'ai identifiÃ© le(s) cas de base
- [ ] Je sais quoi faire avec `Vide`
- [ ] Je sais quoi faire avec `tete`
- [ ] Je sais quoi faire avec `queue`
- [ ] Je comprends comment combiner tÃªte et rÃ©sultat rÃ©cursif
- [ ] J'ai vÃ©rifiÃ© que je me rapproche du cas de base

---

## ğŸ’¡ Conseils Finaux

1. **Ne pense JAMAIS Ã  toute la liste** - juste au premier Ã©lÃ©ment
2. **Fais confiance Ã  la rÃ©cursion** - elle gÃ¨re le reste
3. **Teste sur des petits exemples** - [], [1], [1,2]
4. **Lis les exemples fournis** - ils t'aident Ã  comprendre
5. **Commence par les fonctions simples** - taille, somme, contient
6. **Utilise les fonctions dÃ©jÃ  Ã©crites** - range pour range2, etc.

---

## ğŸš€ Tu es PrÃªt !

Avec ces concepts, tu peux rÃ©soudre TOUS les exercices du fichier. N'oublie pas :
- Pattern matching pour dÃ©construire
- RÃ©cursion pour traiter
- Cas de base pour arrÃªter

Bon courage ! ğŸ’ª