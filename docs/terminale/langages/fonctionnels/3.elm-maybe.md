# Le Type `Maybe` en Elm

## üéØ Le Probl√®me

### Que Retourner Quand √áa √âchoue ?

```elm
-- Comment √©crire cette fonction ?
dernierElement : Liste a -> ???
dernierElement lst = ...

-- Probl√®me : Que retourner si la liste est vide ?
dernierElement Vide = ???  -- Pas d'√©l√©ment √† retourner !
```

**En d'autres langages :**
- **Python/Java** : `None` ou `null` ‚Üí crashes possibles
- **C** : Valeur sp√©ciale (-1, 0) ‚Üí ambigu√´
- **Exceptions** : Lourd et impr√©visible

**En Elm : Le type `Maybe` !** ‚ú®

---

## üì¶ D√©finition de `Maybe`

### Le Type

```elm
type Maybe a
    = Nothing       -- Absence de valeur
    | Just a        -- Pr√©sence d'une valeur de type a
```

**Lecture :** Un `Maybe a` est **SOIT** `Nothing` (rien), **SOIT** `Just` une valeur de type `a`.

### Exemples de Valeurs

```elm
-- Maybe Int
Nothing             -- Pas d'entier
Just 42             -- L'entier 42

-- Maybe String
Nothing             -- Pas de cha√Æne
Just "hello"        -- La cha√Æne "hello"

-- Maybe Bool
Nothing             -- Pas de bool√©en
Just True           -- Le bool√©en True
```

---

## üí° Intuition

### Maybe = Bo√Æte Optionnelle

```elm
Just 5       -- Bo√Æte contenant 5
Nothing      -- Bo√Æte vide
```

**Analogie :**
- **Bo√Æte ferm√©e avec un cadeau** ‚Üí `Just valeur`
- **Bo√Æte vide** ‚Üí `Nothing`

### En Comparaison avec d'Autres Langages

| Langage | √âquivalent | Probl√®me |
|---------|------------|----------|
| Python | `None` | Pas typ√©, crash possible |
| Java | `null` | NullPointerException |
| JavaScript | `null`/`undefined` | Confusion |
| Rust | `Option<T>` | M√™me concept ! ‚úÖ |
| Haskell | `Maybe a` | Identique ‚úÖ |
| **Elm** | `Maybe a` | S√ªr √† la compilation ‚úÖ |

---

## üîç Utilisation avec les Listes

### Exemple 1 : `premier` (head)

```elm
-- Renvoie le premier √©l√©ment d'une liste
premier : Liste a -> Maybe a
premier lst =
    case lst of
        Vide -> Nothing                    -- Pas d'√©l√©ment
        Cons tete queue -> Just tete       -- On a un √©l√©ment !
```

**Utilisation :**
```elm
premier [1, 2, 3]
--> Just 1

premier []
--> Nothing
```

### Exemple 2 : `dernierElement`

```elm
-- Renvoie le dernier √©l√©ment d'une liste
dernierElement : Liste a -> Maybe a
dernierElement lst =
    case lst of
        Vide -> Nothing                              -- Liste vide
        Cons tete Vide -> Just tete                  -- Un seul √©l√©ment
        Cons _ queue -> dernierElement queue         -- Continue la recherche
```

**Utilisation :**
```elm
dernierElement [1, 2, 3]
--> Just 3

dernierElement []
--> Nothing

dernierElement [42]
--> Just 42
```

**Trace d'ex√©cution :**
```
dernierElement [1, 2, 3]
= dernierElement [2, 3]          (pas le dernier)
= dernierElement [3]             (pas le dernier)
= Just 3                         (un seul √©l√©ment !)
```

---

## üé® Pattern Matching sur Maybe

### D√©construire un Maybe

```elm
case monMaybe of
    Nothing -> ...       -- Cas o√π il n'y a rien
    Just valeur -> ...   -- Cas o√π on a une valeur
```

### Exemple : Afficher un R√©sultat

```elm
afficherResultat : Maybe Int -> String
afficherResultat resultat =
    case resultat of
        Nothing -> "Aucun r√©sultat"
        Just n -> "Le r√©sultat est : " ++ String.fromInt n
```

**Utilisation :**
```elm
afficherResultat (Just 42)
--> "Le r√©sultat est : 42"

afficherResultat Nothing
--> "Aucun r√©sultat"
```

---

## üõ†Ô∏è Fonctions Utiles sur Maybe

### `Maybe.withDefault` : Valeur par D√©faut

```elm
-- Si Nothing, utilise la valeur par d√©faut
Maybe.withDefault : a -> Maybe a -> a

-- Exemples
Maybe.withDefault 0 (Just 5)
--> 5

Maybe.withDefault 0 Nothing
--> 0

Maybe.withDefault "inconnu" (Just "Alice")
--> "Alice"

Maybe.withDefault "inconnu" Nothing
--> "inconnu"
```

**Utilisation pratique :**
```elm
-- Obtenir le premier √©l√©ment ou 0 par d√©faut
premierOuZero : Liste Int -> Int
premierOuZero lst =
    premier lst
        |> Maybe.withDefault 0

premierOuZero [1, 2, 3]
--> 1

premierOuZero []
--> 0
```

### `Maybe.map` : Transformer la Valeur

```elm
-- Applique une fonction si Just, sinon reste Nothing
Maybe.map : (a -> b) -> Maybe a -> Maybe b

-- Exemples
Maybe.map (\x -> x * 2) (Just 5)
--> Just 10

Maybe.map (\x -> x * 2) Nothing
--> Nothing

Maybe.map String.length (Just "hello")
--> Just 5
```

**Cas d'usage :**
```elm
-- Doubler le premier √©l√©ment
doublerPremier : Liste Int -> Maybe Int
doublerPremier lst =
    premier lst
        |> Maybe.map (\x -> x * 2)

doublerPremier [5, 10, 15]
--> Just 10

doublerPremier []
--> Nothing
```

---

## ‚ö†Ô∏è Erreurs Courantes

### Erreur 1 : Oublier le `Just`

```elm
-- ‚ùå ERREUR
premier : Liste a -> Maybe a
premier lst =
    case lst of
        Vide -> Nothing
        Cons tete queue -> tete  -- Manque Just !

-- ‚úÖ CORRECT
premier : Liste a -> Maybe a
premier lst =
    case lst of
        Vide -> Nothing
        Cons tete queue -> Just tete
```

### Erreur 2 : Oublier le Cas `Nothing`

```elm
-- ‚ùå ERREUR : Pattern matching incomplet
utiliser : Maybe Int -> Int
utiliser m =
    case m of
        Just x -> x * 2
        -- Manque le cas Nothing !

-- ‚úÖ CORRECT
utiliser : Maybe Int -> Int
utiliser m =
    case m of
        Just x -> x * 2
        Nothing -> 0  -- Valeur par d√©faut
```

### Erreur 3 : Retourner `Nothing` au Lieu de `Just Nothing`

```elm
-- Type Maybe (Maybe a) : un Maybe dans un Maybe !

trouverPuis : (a -> Maybe b) -> Maybe a -> Maybe (Maybe b)
trouverPuis f m =
    case m of
        Nothing -> Nothing           -- Pas de valeur de base
        Just x -> Just (f x)         -- Just du r√©sultat (qui peut √™tre Nothing)
        
-- Exemple
trouverPuis premier (Just [1, 2, 3])
--> Just (Just 1)

trouverPuis premier (Just [])
--> Just Nothing  -- ‚ö†Ô∏è Pas juste Nothing !

trouverPuis premier Nothing
--> Nothing
```

---

## üîó Cha√Æner des Maybe

### Probl√®me : Maybe Imbriqu√©s

```elm
-- Obtenir le premier √©l√©ment du dernier √©l√©ment (si c'est une liste de listes)

-- Version na√Øve
getPremierDuDernier : Liste (Liste a) -> Maybe (Maybe a)
getPremierDuDernier listes =
    case dernierElement listes of
        Nothing -> Nothing
        Just derniereListe -> Just (premier derniereListe)

-- R√©sultat : Maybe (Maybe a) üòï
```

### Solution : `Maybe.andThen`

```elm
-- Maybe.andThen : (a -> Maybe b) -> Maybe a -> Maybe b
-- "Cha√Æne" les Maybe sans les imbriquer

getPremierDuDernier : Liste (Liste a) -> Maybe a
getPremierDuDernier listes =
    dernierElement listes
        |> Maybe.andThen premier

-- Exemples
getPremierDuDernier [[1, 2], [3, 4], [5, 6]]
--> Just 5  (premier de [5, 6])

getPremierDuDernier [[1, 2], [3, 4], []]
--> Nothing  (dernier = [], qui n'a pas de premier)

getPremierDuDernier []
--> Nothing  (pas de dernier)
```

---

## üéì Exemple Complet : `minimum`

### Trouver le Minimum d'une Liste

```elm
-- Renvoie le plus petit √©l√©ment (s'il existe)
minimum : Liste comparable -> Maybe comparable
minimum lst =
    case lst of
        Vide -> Nothing
        Cons premier reste ->
            case minimum reste of
                Nothing -> Just premier          -- Premier est le seul √©l√©ment
                Just minReste ->
                    if premier < minReste then
                        Just premier             -- Premier est plus petit
                    else
                        Just minReste            -- minReste est plus petit
```

**Utilisation :**
```elm
minimum [3, 1, 4, 1, 5]
--> Just 1

minimum [42]
--> Just 42

minimum []
--> Nothing
```

**Trace d'ex√©cution :**
```elm
minimum [3, 1, 4]
= case minimum [1, 4] of          -- 3 vs min([1,4])
    Just 1 -> if 3 < 1 then Just 3 else Just 1
= Just 1

minimum [5]
= case minimum [] of              -- 5 vs rien
    Nothing -> Just 5
= Just 5
```

---

## üí™ Exercices (√Ä Faire)

### Exercice 1 : `elementA`
√âcris une fonction qui retourne l'√©l√©ment √† la position `n` (commence √† 0).

```elm
elementA : Int -> Liste a -> Maybe a

-- Exemples attendus
elementA 0 [1, 2, 3]  --> Just 1
elementA 2 [1, 2, 3]  --> Just 3
elementA 5 [1, 2, 3]  --> Nothing
elementA -1 [1, 2, 3] --> Nothing
```

**Indice :** Utilise `drop` et `premier`.

### Exercice 2 : `maximum`
√âcris une fonction qui retourne le plus grand √©l√©ment.

```elm
maximum : Liste comparable -> Maybe comparable

-- Exemples attendus
maximum [3, 1, 4, 1, 5]  --> Just 5
maximum []               --> Nothing
```

**Indice :** Similaire √† `minimum`, mais avec `>` au lieu de `<`.

### Exercice 3 : `trouver`
√âcris une fonction qui retourne le premier √©l√©ment satisfaisant un pr√©dicat.

```elm
trouver : (a -> Bool) -> Liste a -> Maybe a

-- Exemples attendus
trouver (\x -> x > 3) [1, 2, 3, 4, 5]  --> Just 4
trouver (\x -> x > 10) [1, 2, 3]       --> Nothing
```

---

## üéØ Pourquoi Maybe est Important ?

### 1. S√©curit√© √† la Compilation

```elm
-- ‚ùå Impossible en Elm
x = premier []
y = x + 1  -- Erreur de compilation !

-- ‚úÖ Elm force √† g√©rer le cas Nothing
x = premier []
y = case x of
    Just n -> n + 1
    Nothing -> 0
```

**Pas de crash √† l'ex√©cution !** üõ°Ô∏è

### 2. Code Explicite

```elm
-- La signature dit tout
dernierElement : Liste a -> Maybe a
--                          ‚Üë
--                          "Peut √©chouer !"

-- vs en Python
def last_element(lst):  # Peut retourner None... ou crasher ?
    ...
```

### 3. Forcer √† Penser aux Cas d'Erreur

```elm
-- Tu DOIS g√©rer Nothing
case premier maListe of
    Nothing -> ...  -- Oblig√© de penser √† ce cas
    Just x -> ...
```

---

## üìä Maybe vs Autres Approches

| Approche | Probl√®me | Elm avec Maybe |
|----------|----------|----------------|
| Valeur sp√©ciale (-1, "") | Ambigu√´ | Explicite avec type |
| Exception | Invisible, peut crasher | Visible dans signature |
| `null`/`None` | Pas v√©rifi√© √† la compilation | V√©rifi√© ! |
| **Maybe** | **Aucun** | **‚úÖ Parfait** |

---

## üîÑ Pattern R√©current

### Le Sch√©ma Maybe

```elm
maFonction : Entr√©ePeut-√ätreVide -> Maybe R√©sultat
maFonction entree =
    case entree of
        CasVide -> Nothing                    -- √âchec
        CasNonVide donn√©es -> Just r√©sultat   -- Succ√®s
```

**Exemples :**
- Liste vide ‚Üí `Nothing`
- Division par z√©ro ‚Üí `Nothing`
- Cl√© inexistante dans dictionnaire ‚Üí `Nothing`
- Parsing √©chou√© ‚Üí `Nothing`

---

## ‚úÖ R√©sum√©

### Qu'est-ce que Maybe ?

```elm
type Maybe a = Nothing | Just a
```

- **`Nothing`** : Absence de valeur (√©chec, vide, erreur)
- **`Just valeur`** : Pr√©sence d'une valeur

### Quand Utiliser Maybe ?

Utilise `Maybe a` pour le type de retour d'une fonction quand :
- ‚úÖ La fonction peut √©chouer
- ‚úÖ Il peut ne pas y avoir de r√©sultat
- ‚úÖ L'entr√©e peut √™tre vide

### Fonctions Cl√©s

```elm
-- Valeur par d√©faut
Maybe.withDefault : a -> Maybe a -> a

-- Transformer
Maybe.map : (a -> b) -> Maybe a -> Maybe b

-- Cha√Æner
Maybe.andThen : (a -> Maybe b) -> Maybe a -> Maybe b
```

### Le Pattern

```elm
case monMaybe of
    Nothing -> -- G√©rer l'absence
    Just valeur -> -- Utiliser la valeur
```

---

## üí° Conseil Final

**Si ta fonction peut "√©chouer" ou "ne rien retourner", utilise `Maybe` !**

```elm
-- ‚úÖ Bon
premier : Liste a -> Maybe a

-- ‚ùå Mauvais (impossible de repr√©senter l'√©chec)
premier : Liste a -> a  -- Et si la liste est vide ???
```

**Maybe = S√©curit√© + Clart√© + Pas de surprise !** üéØ

---

## üìö Pour Aller Plus Loin

Une fois que tu ma√Ætrises `Maybe`, tu peux d√©couvrir `Result` : Pour les erreurs avec message.

Mais pour l'instant, **`Maybe` est d√©j√† tr√®s puissant !** üí™
