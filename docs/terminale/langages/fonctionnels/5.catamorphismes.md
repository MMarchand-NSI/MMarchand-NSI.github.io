# 5. Bien avanc√© - Catamorphismes

## üéØ Introduction

C'est un bien gros mot pour d√©crire formellement ce que tu as d√©j√† appris √† faire.

Tu as appris `foldr`. Maintenant, d√©couvrons le **vrai nom** de ce que tu fais depuis le d√©but : les **catamorphismes**.

**Spoiler :** `foldr` est un catamorphisme !

---

## 1. Le Mot Qui Fait Peur

**Catamorphisme** (du grec Œ∫Œ±œÑŒ¨ "vers le bas" + ŒºŒøœÅœÜŒÆ "forme")

**Traduction simple :** "D√©construire une structure en descendant vers quelque chose de plus simple"

**En encore plus simple :** "Transformer une structure r√©cursive en une valeur"

---

## 2. Rappel : Ta Liste est une Structure R√©cursive

```elm
type Liste a
    = Vide
    | Cons a (Liste a)
```

**Une liste, c'est :**
- SOIT `Vide`
- SOIT construite avec `Cons` + un √©l√©ment + une autre liste

**C'est r√©cursif** : une liste contient une liste !

```
Cons 1 (Cons 2 (Cons 3 Vide))
  ‚Üë       ‚Üë       ‚Üë      ‚Üë
  Cons    Cons    Cons   Vide
```

---

## 3. Le Catamorphisme = "D√©-construire"

### Construction vs D√©construction

**Construction** (cr√©er une liste) :
```elm
-- Je CONSTRUIS avec Cons et Vide
maListe = Cons 1 (Cons 2 (Cons 3 Vide))
```

**D√©construction** (d√©truire une liste pour en extraire une valeur) :
```elm
-- Je D√âCONSTRUIS avec foldr
taille maListe = foldr (\_ acc -> 1 + acc) 0 maListe
--> 3
```

**Le catamorphisme, c'est la d√©construction syst√©matique !**

---

## 4. L'Intuition Visuelle

### Construction d'une liste

```
        Cons
       /    \
      1     Cons
           /    \
          2     Cons
               /    \
              3     Vide
```

### Catamorphisme (foldr)

```
        f
       / \
      1   f
         / \
        2   f
           / \
          3  acc
```

**On remplace :**
- Chaque `Cons` par notre fonction `f`
- `Vide` par notre accumulator `acc`

---

## 5. Le Pattern Universel

### Toute structure r√©cursive a son catamorphisme

**Pour les listes :**
```elm
type Liste a = Vide | Cons a (Liste a)

-- Son catamorphisme :
foldr : (a -> b -> b) -> b -> Liste a -> b
--       ‚Üë pour Cons    ‚Üë pour Vide
```

**Pour les arbres binaires :**
```elm
type Arbre a = Feuille | Noeud a (Arbre a) (Arbre a)

-- Son catamorphisme :
foldArbre : b -> (a -> b -> b -> b) -> Arbre a -> b
--          ‚Üë     ‚Üë pour Noeud          ‚Üë
--      pour Feuille              structure √† d√©construire
```

**Pour les Maybe :**
```elm
type Maybe a = Nothing | Just a

-- Son catamorphisme :
foldMaybe : b -> (a -> b) -> Maybe a -> b
--          ‚Üë     ‚Üë pour Just
--      pour Nothing
```

---

## 6. La Formule Magique d'un Catamorphisme

### √âtape 1 : Regarde ton type

```elm
type Liste a
    = Vide              -- Constructeur 1 (0 argument r√©cursif)
    | Cons a (Liste a)  -- Constructeur 2 (1 argument + 1 r√©cursif)
```

### √âtape 2 : Cr√©e le catamorphisme

**Pour chaque constructeur, fournis un "rempla√ßant" :**

```elm
foldr : (a -> b -> b) -> b -> Liste a -> b
        ‚Üë              ‚Üë
        remplace Cons  remplace Vide
```

**D√©tail :**
- `Vide` ‚Üí `b` (juste une valeur)
- `Cons a (Liste a)` ‚Üí `(a -> b -> b)` (fonction qui prend l'√©l√©ment et le r√©sultat r√©cursif)

### √âtape 3 : Impl√©mente

```elm
foldr : (a -> b -> b) -> b -> Liste a -> b
foldr fCons fVide lst =
    case lst of
        Vide -> fVide                           -- Applique fVide
        Cons tete queue -> fCons tete (foldr fCons fVide queue)
        --                 ‚Üë     ‚Üë      ‚Üë
        --                 fonction  √©l√©ment  r√©sultat r√©cursif
```

---

## 7. Exemples Concrets

### Exemple 1 : Taille

**Question :** Comment remplacer les constructeurs ?

```elm
-- Liste originale
Cons 1 (Cons 2 (Cons 3 Vide))

-- Pour calculer la taille :
-- - Remplace chaque Cons par "1 +"
-- - Remplace Vide par 0

(1 +) ((1 +) ((1 +) 0))
= 3
```

**En code :**
```elm
taille = foldr (\_ acc -> 1 + acc) 0
--             ‚Üë                   ‚Üë
--             remplace Cons       remplace Vide
```

### Exemple 2 : Somme

```elm
-- Liste originale
Cons 5 (Cons 3 (Cons 2 Vide))

-- Pour calculer la somme :
-- - Remplace chaque Cons par +
-- - Remplace Vide par 0

5 + (3 + (2 + 0))
= 10
```

**En code :**
```elm
somme = foldr (+) 0
--            ‚Üë   ‚Üë
--            remplace Cons  remplace Vide
```

### Exemple 3 : Identit√© (ne rien changer)

```elm
-- Que se passe-t-il si je remplace Cons par Cons et Vide par Vide ?

identite = foldr Cons Vide

-- Trace
identite (Cons 1 (Cons 2 Vide))
= Cons 1 (identite (Cons 2 Vide))
= Cons 1 (Cons 2 (identite Vide))
= Cons 1 (Cons 2 Vide)

-- Je recr√©e la m√™me liste !
```

---

## 8. Catamorphisme vs R√©cursion Manuelle

### R√©cursion manuelle

```elm
taille : Liste a -> Int
taille lst =
    case lst of
        Vide -> 0
        Cons _ queue -> 1 + taille queue
```

**Ce que tu fais :**
1. Pattern matching sur les constructeurs
2. Pour chaque constructeur, dis quoi faire
3. Rappelle r√©cursivement la fonction

### Catamorphisme

```elm
taille = foldr (\_ acc -> 1 + acc) 0
```

**Ce que tu fais :**
1. Fournis un "rempla√ßant" pour chaque constructeur
2. Le catamorphisme fait la r√©cursion pour toi

**Avantage :** Tu n'√©cris plus le pattern matching, c'est fait une fois pour toutes !

---

## 9. Pourquoi C'est Important ?

### 1. Abstraction

Au lieu de r√©√©crire 100 fois :
```elm
case lst of
    Vide -> ...
    Cons tete queue -> ... (r√©cursion queue) ...
```

Tu √©cris une fois `foldr` et tu le r√©utilises !

### 2. Garanti Sans Bug

```elm
-- ‚ùå Risque d'oublier un cas
maFonction lst =
    case lst of
        Cons tete queue -> ...
        -- Oups, j'ai oubli√© Vide !

-- ‚úÖ foldr force √† donner les 2 cas
maFonction = foldr fCons fVide
--                 ‚Üë     ‚Üë
--                 obligatoires
```

### 3. Raisonnement Math√©matique

Les catamorphismes ont des **propri√©t√©s prouvables** :

```elm
-- Fusion law
foldr f acc (foldr g base lst) = foldr h acc lst
-- (sous certaines conditions)

-- Universal property
h = foldr f acc  SI ET SEULEMENT SI
    h Vide = acc
    h (Cons x xs) = f x (h xs)
```

Ces propri√©t√©s permettent d'**optimiser automatiquement** ton code !

---

## 10. Le Vocabulaire

### Catamorphisme

- **Cata** = vers le bas
- **Morphisme** = transformation de structure
- **Catamorphisme** = transformer en descendant (d√©construire)

### Autres morphismes

**Anamorphisme** (le contraire) :
- **Ana** = vers le haut
- Construit une structure √† partir d'une graine
- Exemple : `unfold`

```elm
-- G√©n√©rer [1, 2, 3, ..., n]
range : Int -> Liste Int
range n =
    if n <= 0 then
        Vide
    else
        Cons n (range (n - 1))
-- C'est un anamorphisme !
```

**Hylomorphisme** (les deux) :
- **Hylo** = tout ensemble
- Anamorphisme puis catamorphisme
- Exemple : `triFusion`

```elm
triFusion : Liste comparable -> Liste comparable
triFusion lst =
    -- 1. D√©construire en sous-listes (ana)
    -- 2. Reconstruire en fusionnant (cata)
```

---

## 11. Le Lien avec les Math√©matiques

### En th√©orie des cat√©gories

Un catamorphisme est un **morphisme initial** de l'**alg√®bre F-initiale**.

**Traduction :**
- Ta liste est une **alg√®bre** (structure avec op√©rations)
- `Vide` et `Cons` sont tes op√©rations
- `foldr` est le morphisme qui transforme cette alg√®bre en n'importe quelle autre

**Propri√©t√© universelle :**
```elm
Pour toute fonction h : Liste a -> b satisfaisant
    h Vide = base
    h (Cons x xs) = f x (h xs)

Il existe un UNIQUE foldr tel que h = foldr f base
```

**Cons√©quence :** `foldr` est LA mani√®re canonique de d√©finir des fonctions sur les listes !

---

## 12. Application : √âcrire Ton Propre Catamorphisme

### Pour un type custom

```elm
-- Type pour les nombres naturels
type Nat = Zero | Succ Nat

-- 0, 1, 2, 3 s'√©crit :
-- Zero, Succ Zero, Succ (Succ Zero), Succ (Succ (Succ Zero))

-- Son catamorphisme
foldNat : b -> (b -> b) -> Nat -> b
foldNat zero succ n =
    case n of
        Zero -> zero
        Succ pred -> succ (foldNat zero succ pred)

-- Exemples
toInt : Nat -> Int
toInt = foldNat 0 (\acc -> acc + 1)

double : Nat -> Nat
double = foldNat Zero (\acc -> Succ (Succ acc))
```

### Pour un arbre binaire

```elm
type Arbre a
    = Feuille
    | Noeud a (Arbre a) (Arbre a)

-- Son catamorphisme
foldArbre : b -> (a -> b -> b -> b) -> Arbre a -> b
foldArbre feuille noeud arbre =
    case arbre of
        Feuille -> feuille
        Noeud valeur gauche droite ->
            noeud valeur
                (foldArbre feuille noeud gauche)
                (foldArbre feuille noeud droite)

-- Exemples
tailleArbre : Arbre a -> Int
tailleArbre = foldArbre 0 (\_ g d -> 1 + g + d)

sommeArbre : Arbre Int -> Int
sommeArbre = foldArbre 0 (\val g d -> val + g + d)
```

---

## 13. La Recette pour Cr√©er un Catamorphisme

### √âtapes

1. **Identifie les constructeurs de ton type**
   ```elm
   type MonType a = Constructeur1 ... | Constructeur2 ...
   ```

2. **Pour chaque constructeur, cr√©e un param√®tre de fonction**
   - Constructeur sans r√©cursion ‚Üí valeur simple
   - Constructeur avec r√©cursion ‚Üí fonction

3. **Impl√©mente avec pattern matching**
   - Applique le param√®tre correspondant
   - Pour les parties r√©cursives, appelle r√©cursivement le catamorphisme

4. **Utilise-le !**

### Exemple : Maybe

```elm
-- 1. Type
type Maybe a = Nothing | Just a

-- 2. Param√®tres
-- Nothing ‚Üí b (valeur)
-- Just a ‚Üí (a -> b) (fonction)

-- 3. Impl√©mentation
foldMaybe : b -> (a -> b) -> Maybe a -> b
foldMaybe nothing just m =
    case m of
        Nothing -> nothing
        Just x -> just x

-- 4. Utilisation
getOr : a -> Maybe a -> a
getOr default = foldMaybe default (\x -> x)

isJust : Maybe a -> Bool
isJust = foldMaybe False (\_ -> True)
```

---

## 14. Pourquoi "Catamorphisme" et pas "Fold" ?

### Histoire

- **1960s-70s** : Concept d√©couvert en th√©orie des cat√©gories
- **1980s** : Appliqu√© en programmation fonctionnelle (ML, Miranda)
- **1990s** : Bananas paper (Erik Meijer) popularise le terme
- **Aujourd'hui** : `fold` en pratique, catamorphisme en th√©orie

### Noms √©quivalents

| Terme | Langage/Contexte |
|-------|------------------|
| `foldr` | Haskell, Elm |
| `reduce` | JavaScript, Python |
| `inject` | Ruby |
| `aggregate` | LINQ (C#) |
| **catamorphisme** | Th√©orie des cat√©gories |

**Tous d√©crivent la m√™me chose !**

---

## 15. Le Sch√©ma de R√©cursion Universel

### Tout est un catamorphisme !

```elm
-- Addition
add : Nat -> Nat -> Nat
add n m = foldNat m Succ n

-- Multiplication
mult : Nat -> Nat -> Nat
mult n m = foldNat Zero (\acc -> add m acc) n

-- Concat√©nation
concat : Liste a -> Liste a -> Liste a
concat xs ys = foldr Cons ys xs

-- Map
map : (a -> b) -> Liste a -> Liste b
map f = foldr (\x acc -> Cons (f x) acc) Vide

-- Filter
filter : (a -> Bool) -> Liste a -> Liste a
filter p = foldr (\x acc -> if p x then Cons x acc else acc) Vide
```

**Presque toutes les fonctions sur des structures r√©cursives peuvent s'√©crire comme catamorphismes !**

---

## 16. En R√©sum√©

### Ce qu'est un catamorphisme

1. **Une d√©construction syst√©matique** d'une structure r√©cursive
2. **Un remplacement** de chaque constructeur par une op√©ration
3. **Une abstraction** du pattern r√©cursif

### Pourquoi c'est utile

‚úÖ Moins de code r√©p√©titif  
‚úÖ Moins d'erreurs  
‚úÖ Raisonnement math√©matique possible  
‚úÖ Optimisations automatiques  
‚úÖ Base de la programmation g√©n√©rique

### La formule magique

```
Structure r√©cursive
    ‚Üì
Catamorphisme (remplace les constructeurs)
    ‚Üì
Valeur
```

---

## 17. Exercice Mental

**Sans coder, r√©fl√©chis :**

1. `contient` peut-il s'√©crire avec `foldr` ?
   - Probl√®me : il faudrait arr√™ter t√¥t, mais `foldr` parcourt tout
   - Solution partielle possible avec `||` mais inefficace

2. `removeAllElt` avec `foldr` ?
   - Base : `Vide`
   - Combinaison : si `tete == e` alors skip, sinon `Cons tete acc`
   - **Oui, c'est possible !**

3. `triFusion` avec `foldr` ?
   - Non direct, c'est un hylomorphisme (d√©construit puis reconstruit)
   - Mais `fusion` peut s'√©crire avec `foldr` !

---

## üéØ Conclusion

**Tu faisais des catamorphismes depuis le d√©but sans le savoir !**

`foldr` n'est pas juste une fonction utile, c'est **LE** pattern fondamental pour travailler avec des structures r√©cursives.

**Citation finale :**

> "Un catamorphisme, c'est comme une recette de cuisine :  
> Tu prends ta structure, tu remplaces chaque ingr√©dient (constructeur)  
> par une op√©ration, et tu obtiens ton plat (r√©sultat)."

Maintenant quand quelqu'un te demande "C'est quoi `foldr` ?", tu peux r√©pondre :

**"C'est le catamorphisme des listes !"** üéì

Et si ils demandent "C'est quoi un catamorphisme ?", r√©ponds :

**"C'est la mani√®re canonique de d√©construire une structure r√©cursive en rempla√ßant ses constructeurs par des op√©rations."**

Tu es maintenant initi√© √† la th√©orie des cat√©gories ! üöÄ
