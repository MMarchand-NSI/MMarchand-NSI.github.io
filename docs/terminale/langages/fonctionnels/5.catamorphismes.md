# 5. Bien avancÃ© - Catamorphismes

## ğŸ¯ Introduction

C'est un bien gros mot pour dÃ©crire formellement ce que tu as dÃ©jÃ  appris Ã  faire.

Tu as appris `foldr`. Maintenant, dÃ©couvrons le **vrai nom** de ce que tu fais depuis le dÃ©but : les **catamorphismes**.

**Spoiler :** `foldr` est un catamorphisme !

---

## 1. Le Mot Qui Fait Peur

**Catamorphisme** (du grec ÎºÎ±Ï„Î¬ "vers le bas" + Î¼Î¿ÏÏ†Î® "forme")

**Traduction simple :** "DÃ©construire une structure en descendant vers quelque chose de plus simple"

**En encore plus simple :** "Transformer une structure rÃ©cursive en une valeur"

---

## 2. Rappel : Ta Liste est une Structure RÃ©cursive

```elm
type Liste a
    = Vide
    | Cons a (Liste a)
```

**Une liste, c'est :**

- SOIT `Vide`
- SOIT construite avec `Cons` + un Ã©lÃ©ment + une autre liste

**C'est rÃ©cursif** : une liste contient une liste !

```
Cons 1 (Cons 2 (Cons 3 Vide))
  â†‘       â†‘       â†‘      â†‘
  Cons    Cons    Cons   Vide
```

---

## 3. Le Catamorphisme = "DÃ©-construire"

### Construction vs DÃ©construction

**Construction** (crÃ©er une liste) :
```elm
-- Je CONSTRUIS avec Cons et Vide
maListe = Cons 1 (Cons 2 (Cons 3 Vide))
```

**DÃ©construction** (dÃ©truire une liste pour en extraire une valeur) :
```elm
-- Je DÃ‰CONSTRUIS avec foldr
taille maListe = foldr (\_ acc -> 1 + acc) 0 maListe
--> 3
```

**Le catamorphisme, c'est la dÃ©construction systÃ©matique !**

---

## 4. L'Intuition Visuelle

### Construction d'une liste

```
        Cons
       /    \
      1     Cons
           /    \
          2     Cons
               /    \
              3     Vide
```

### Catamorphisme (foldr)

```
        f
       / \
      1   f
         / \
        2   f
           / \
          3  acc
```

**On remplace :**

- Chaque `Cons` par notre fonction `f`
- `Vide` par notre accumulator `acc`

---

## 5. Le Pattern Universel

### Toute structure rÃ©cursive a son catamorphisme

**Pour les listes :**
```elm
type Liste a = Vide | Cons a (Liste a)

-- Son catamorphisme :
foldr : (a -> b -> b) -> b -> Liste a -> b
--       â†‘ pour Cons    â†‘ pour Vide
```

**Pour les arbres binaires :**
```elm
type Arbre a = Feuille | Noeud a (Arbre a) (Arbre a)

-- Son catamorphisme :
foldArbre : b -> (a -> b -> b -> b) -> Arbre a -> b
--          â†‘     â†‘ pour Noeud          â†‘
--      pour Feuille              structure Ã  dÃ©construire
```

**Pour les Maybe :**
```elm
type Maybe a = Nothing | Just a

-- Son catamorphisme :
foldMaybe : b -> (a -> b) -> Maybe a -> b
--          â†‘     â†‘ pour Just
--      pour Nothing
```

---

## 6. La Formule Magique d'un Catamorphisme

### Ã‰tape 1 : Regarde ton type

```elm
type Liste a
    = Vide              -- Constructeur 1 (0 argument rÃ©cursif)
    | Cons a (Liste a)  -- Constructeur 2 (1 argument + 1 rÃ©cursif)
```

### Ã‰tape 2 : CrÃ©e le catamorphisme

**Pour chaque constructeur, fournis un "remplaÃ§ant" :**

```elm
foldr : (a -> b -> b) -> b -> Liste a -> b
        â†‘              â†‘
        remplace Cons  remplace Vide
```

**DÃ©tail :**

- `Vide` â†’ `b` (juste une valeur)
- `Cons a (Liste a)` â†’ `(a -> b -> b)` (fonction qui prend l'Ã©lÃ©ment et le rÃ©sultat rÃ©cursif)

### Ã‰tape 3 : ImplÃ©mente

```elm
foldr : (a -> b -> b) -> b -> Liste a -> b
foldr fCons fVide lst =
    case lst of
        Vide -> fVide                           -- Applique fVide
        Cons tete queue -> fCons tete (foldr fCons fVide queue)
        --                 â†‘     â†‘      â†‘
        --                 fonction  Ã©lÃ©ment  rÃ©sultat rÃ©cursif
```

---

## 7. Exemples Concrets

### Exemple 1 : Taille

**Question :** Comment remplacer les constructeurs ?

```elm
-- Liste originale
Cons 1 (Cons 2 (Cons 3 Vide))

-- Pour calculer la taille :
-- - Remplace chaque Cons par "1 +"
-- - Remplace Vide par 0

(1 +) ((1 +) ((1 +) 0))
= 3
```

**En code :**
```elm
taille = foldr (\_ acc -> 1 + acc) 0
--             â†‘                   â†‘
--             remplace Cons       remplace Vide
```

### Exemple 2 : Somme

```elm
-- Liste originale
Cons 5 (Cons 3 (Cons 2 Vide))

-- Pour calculer la somme :
-- - Remplace chaque Cons par +
-- - Remplace Vide par 0

5 + (3 + (2 + 0))
= 10
```

**En code :**
```elm
somme = foldr (+) 0
--            â†‘   â†‘
--            remplace Cons  remplace Vide
```

### Exemple 3 : IdentitÃ© (ne rien changer)

```elm
-- Que se passe-t-il si je remplace Cons par Cons et Vide par Vide ?

identite = foldr Cons Vide

-- Trace
identite (Cons 1 (Cons 2 Vide))
= Cons 1 (identite (Cons 2 Vide))
= Cons 1 (Cons 2 (identite Vide))
= Cons 1 (Cons 2 Vide)

-- Je recrÃ©e la mÃªme liste !
```

---

## 8. Catamorphisme vs RÃ©cursion Manuelle

### RÃ©cursion manuelle

```elm
taille : Liste a -> Int
taille lst =
    case lst of
        Vide -> 0
        Cons _ queue -> 1 + taille queue
```

**Ce que tu fais :**

1. Pattern matching sur les constructeurs
2. Pour chaque constructeur, dis quoi faire
3. Rappelle rÃ©cursivement la fonction

### Catamorphisme

```elm
taille = foldr (\_ acc -> 1 + acc) 0
```

**Ce que tu fais :**

1. Fournis un "remplaÃ§ant" pour chaque constructeur
2. Le catamorphisme fait la rÃ©cursion pour toi

**Avantage :** Tu n'Ã©cris plus le pattern matching, c'est fait une fois pour toutes !

---

## 9. Pourquoi C'est Important ?

### 1. Abstraction

Au lieu de rÃ©Ã©crire 100 fois :
```elm
case lst of
    Vide -> ...
    Cons tete queue -> ... (rÃ©cursion queue) ...
```

Tu Ã©cris une fois `foldr` et tu le rÃ©utilises !

### 2. Garanti Sans Bug

```elm
-- âŒ Risque d'oublier un cas
maFonction lst =
    case lst of
        Cons tete queue -> ...
        -- Oups, j'ai oubliÃ© Vide !

-- âœ… foldr force Ã  donner les 2 cas
maFonction = foldr fCons fVide
--                 â†‘     â†‘
--                 obligatoires
```

### 3. Raisonnement MathÃ©matique

Les catamorphismes ont des **propriÃ©tÃ©s prouvables** :

```elm
-- Fusion law
foldr f acc (foldr g base lst) = foldr h acc lst
-- (sous certaines conditions)

-- Universal property
h = foldr f acc  SI ET SEULEMENT SI
    h Vide = acc
    h (Cons x xs) = f x (h xs)
```

Ces propriÃ©tÃ©s permettent d'**optimiser automatiquement** ton code !

---

## 10. Le Vocabulaire

### Catamorphisme

- **Cata** = vers le bas
- **Morphisme** = transformation de structure
- **Catamorphisme** = transformer en descendant (dÃ©construire)

### Autres morphismes

**Anamorphisme** (le contraire) :

- **Ana** = vers le haut
- Construit une structure Ã  partir d'une graine
- Exemple : `unfold`

```elm
-- GÃ©nÃ©rer [1, 2, 3, ..., n]
range : Int -> Liste Int
range n =
    if n <= 0 then
        Vide
    else
        Cons n (range (n - 1))
-- C'est un anamorphisme !
```

**Hylomorphisme** (les deux) :

- **Hylo** = tout ensemble
- Anamorphisme puis catamorphisme
- Exemple : `triFusion`

```elm
triFusion : Liste comparable -> Liste comparable
triFusion lst =
    -- 1. DÃ©construire en sous-listes (ana)
    -- 2. Reconstruire en fusionnant (cata)
```

---

## 11. Le Lien avec les MathÃ©matiques

### En thÃ©orie des catÃ©gories

Un catamorphisme est un **morphisme initial** de l'**algÃ¨bre F-initiale**.

**Traduction :**
- Ta liste est une **algÃ¨bre** (structure avec opÃ©rations)
- `Vide` et `Cons` sont tes opÃ©rations
- `foldr` est le morphisme qui transforme cette algÃ¨bre en n'importe quelle autre

**PropriÃ©tÃ© universelle :**
```elm
Pour toute fonction h : Liste a -> b satisfaisant
    h Vide = base
    h (Cons x xs) = f x (h xs)

Il existe un UNIQUE foldr tel que h = foldr f base
```

**ConsÃ©quence :** `foldr` est LA maniÃ¨re canonique de dÃ©finir des fonctions sur les listes !

---

## 12. Application : Ã‰crire Ton Propre Catamorphisme

### Pour un type custom

```elm
-- Type pour les nombres naturels
type Nat = Zero | Succ Nat

-- 0, 1, 2, 3 s'Ã©crit :
-- Zero, Succ Zero, Succ (Succ Zero), Succ (Succ (Succ Zero))

-- Son catamorphisme
foldNat : b -> (b -> b) -> Nat -> b
foldNat zero succ n =
    case n of
        Zero -> zero
        Succ pred -> succ (foldNat zero succ pred)

-- Exemples
toInt : Nat -> Int
toInt = foldNat 0 (\acc -> acc + 1)

double : Nat -> Nat
double = foldNat Zero (\acc -> Succ (Succ acc))
```

### Pour un arbre binaire

```elm
type Arbre a
    = Feuille
    | Noeud a (Arbre a) (Arbre a)

-- Son catamorphisme
foldArbre : b -> (a -> b -> b -> b) -> Arbre a -> b
foldArbre feuille noeud arbre =
    case arbre of
        Feuille -> feuille
        Noeud valeur gauche droite ->
            noeud valeur
                (foldArbre feuille noeud gauche)
                (foldArbre feuille noeud droite)

-- Exemples
tailleArbre : Arbre a -> Int
tailleArbre = foldArbre 0 (\_ g d -> 1 + g + d)

sommeArbre : Arbre Int -> Int
sommeArbre = foldArbre 0 (\val g d -> val + g + d)
```

---

## 13. La Recette pour CrÃ©er un Catamorphisme

### Ã‰tapes

1. **Identifie les constructeurs de ton type**
   ```elm
   type MonType a = Constructeur1 ... | Constructeur2 ...
   ```

2. **Pour chaque constructeur, crÃ©e un paramÃ¨tre de fonction**
   - Constructeur sans rÃ©cursion â†’ valeur simple
   - Constructeur avec rÃ©cursion â†’ fonction

3. **ImplÃ©mente avec pattern matching**
   - Applique le paramÃ¨tre correspondant
   - Pour les parties rÃ©cursives, appelle rÃ©cursivement le catamorphisme

4. **Utilise-le !**

### Exemple : Maybe

```elm
-- 1. Type
type Maybe a = Nothing | Just a

-- 2. ParamÃ¨tres
-- Nothing â†’ b (valeur)
-- Just a â†’ (a -> b) (fonction)

-- 3. ImplÃ©mentation
foldMaybe : b -> (a -> b) -> Maybe a -> b
foldMaybe nothing just m =
    case m of
        Nothing -> nothing
        Just x -> just x

-- 4. Utilisation
getOr : a -> Maybe a -> a
getOr default = foldMaybe default (\x -> x)

isJust : Maybe a -> Bool
isJust = foldMaybe False (\_ -> True)
```

---

## 14. Pourquoi "Catamorphisme" et pas "Fold" ?

### Histoire

- **1960s-70s** : Concept dÃ©couvert en thÃ©orie des catÃ©gories
- **1980s** : AppliquÃ© en programmation fonctionnelle (ML, Miranda)
- **1990s** : Bananas paper (Erik Meijer) popularise le terme
- **Aujourd'hui** : `fold` en pratique, catamorphisme en thÃ©orie

### Noms Ã©quivalents

| Terme | Langage/Contexte |
|-------|------------------|
| `foldr` | Haskell, Elm |
| `reduce` | JavaScript, Python |
| `inject` | Ruby |
| `aggregate` | LINQ (C#) |
| **catamorphisme** | ThÃ©orie des catÃ©gories |

**Tous dÃ©crivent la mÃªme chose !**

---

## 15. Le SchÃ©ma de RÃ©cursion Universel

### Tout est un catamorphisme !

```elm
-- Addition
add : Nat -> Nat -> Nat
add n m = foldNat m Succ n

-- Multiplication
mult : Nat -> Nat -> Nat
mult n m = foldNat Zero (\acc -> add m acc) n

-- ConcatÃ©nation
concat : Liste a -> Liste a -> Liste a
concat xs ys = foldr Cons ys xs

-- Map
map : (a -> b) -> Liste a -> Liste b
map f = foldr (\x acc -> Cons (f x) acc) Vide

-- Filter
filter : (a -> Bool) -> Liste a -> Liste a
filter p = foldr (\x acc -> if p x then Cons x acc else acc) Vide
```

**Presque toutes les fonctions sur des structures rÃ©cursives peuvent s'Ã©crire comme catamorphismes !**

---

## 16. En RÃ©sumÃ©

### Ce qu'est un catamorphisme

1. **Une dÃ©construction systÃ©matique** d'une structure rÃ©cursive
2. **Un remplacement** de chaque constructeur par une opÃ©ration
3. **Une abstraction** du pattern rÃ©cursif

### Pourquoi c'est utile

âœ… Moins de code rÃ©pÃ©titif  
âœ… Moins d'erreurs  
âœ… Raisonnement mathÃ©matique possible  
âœ… Optimisations automatiques  
âœ… Base de la programmation gÃ©nÃ©rique

### La formule magique

```
Structure rÃ©cursive
    â†“
Catamorphisme (remplace les constructeurs)
    â†“
Valeur
```

---

## 17. Exercice Mental

**Sans coder, rÃ©flÃ©chis :**

1. `contient` peut-il s'Ã©crire avec `foldr` ?
   - ProblÃ¨me : il faudrait arrÃªter tÃ´t, mais `foldr` parcourt tout
   - Solution partielle possible avec `||` mais inefficace

2. `removeAllElt` avec `foldr` ?
   - Base : `Vide`
   - Combinaison : si `tete == e` alors skip, sinon `Cons tete acc`
   - **Oui, c'est possible !**

3. `triFusion` avec `foldr` ?
   - Non direct, c'est un hylomorphisme (dÃ©construit puis reconstruit)
   - Mais `fusion` peut s'Ã©crire avec `foldr` !

---

## ğŸ¯ Conclusion

**Tu faisais des catamorphismes depuis le dÃ©but sans le savoir !**

`foldr` n'est pas juste une fonction utile, c'est **LE** pattern fondamental pour travailler avec des structures rÃ©cursives.

**Citation finale :**

> "Un catamorphisme, c'est comme une recette de cuisine :  
> Tu prends ta structure, tu remplaces chaque ingrÃ©dient (constructeur)  
> par une opÃ©ration, et tu obtiens ton plat (rÃ©sultat)."

Maintenant quand quelqu'un te demande "C'est quoi `foldr` ?", tu peux rÃ©pondre :

**"C'est le catamorphisme des listes !"** ğŸ“

Et si ils demandent "C'est quoi un catamorphisme ?", rÃ©ponds :

**"C'est la maniÃ¨re canonique de dÃ©construire une structure rÃ©cursive en remplaÃ§ant ses constructeurs par des opÃ©rations."**

Tu es maintenant initiÃ© Ã  la thÃ©orie des catÃ©gories ! ğŸš€
