# Les sÃ©quences

Ici, nous allons parler de types qui permettent de stocker une suite d'Ã©lÃ©ments dans une seule variable.

Il s'agit surtout de dÃ©finitions Ã  accepter et Ã  savoir. Ce sont des Ã©lÃ©ments de langage Ã  connaÃ®tre.

!!! abstract "SÃ©quence"
    Une sÃ©quence est une structure de donnÃ©es linÃ©aire qui permet de stocker une suite d'Ã©lÃ©ments. Ces Ã©lÃ©ments ont un ordre. On accÃ¨de Ã  chaque Ã©lÃ©ment de la sÃ©quence par son indice.

    Sur cette page, nous allons Ã©tudier les caractÃ©ristiques communes des sÃ©quences.


## ReconnaÃ®tre les sÃ©quences en python 

!!! abstract "Types de sÃ©quences"
    Les types de sÃ©quences sont les suivants:

    - Chaines de caractÃ¨res (str)
    - Listes (list)
    - Tuples (tuple)

### str

Les str sont les sÃ©quences les plus simples. Une chaÃ®ne de caractÃ¨res de taille $n$ est constituÃ©e de caractÃ¨res numÃ©rotÃ©s de 0 Ã  $n-1$.

On les reconnaÃ®t graphiquement grÃ¢ce aux guillemets. Il en existe de 3 types:

```python
s1 = "Hello"
s2 = 'Hello'
s3 = """ Ceci est une chaÃ®ne
de caractÃ¨res multi-lignes """
s4 = "J'ai gagnÃ©"
```

Vous remarquerez qu'on ne peut pas utiliser les simples guillemets pour s4.

### tuples

Un tuple de taille $n$ est constituÃ© de valeurs numÃ©rotÃ©es de 0 Ã  $n-1$. Les tuples sont gÃ©nÃ©ralement utilisÃ©s dans un contexte oÃ¹ on connaÃ®t Ã  l'avance le nombre d'Ã©lÃ©ments qu'on souhaite stocker. On peut y stocker des donnÃ©es hÃ©tÃ©rogÃ¨nes (qui ne sont pas du mÃªme type).

Voici comment on les reconnaÃ®t:

```python
coordonnees : tuple[int, int]      = (5, 0)
personne1   : tuple[str, int, str] = ("Jean", 16, "Paris")
personne2   : tuple[str, int, str] = ("Alice", 18, "Brest")
```

On les reconnaÃ®t gÃ©nÃ©ralement Ã  leurs parenthÃ¨ses, mais en python, ces parenthÃ¨ses sont facultatives. Ce sont seulement des valeurs sÃ©parÃ©es par des virgules. Voici des instructions Ã©quivalentes aux prÃ©cÃ©dentes:

```python
coordonnees : tuple[int, int]      = 5, 0
personne1   : tuple[str, int, str] = "Jean", 16, "Paris"
personne2   : tuple[str, int, str] = "Alice", 18, "Brest"
```

Par soucis de clartÃ©, on utilisera toujours les parenthÃ¨ses.

Attention, le tuple Ã  1 Ã©lÃ©ment se dÃ©clare ainsi:

```python
coordonnees : tuple[int] = (5,)
```

Si on ne met pas de virgule, python croit qu'on veut simplement mettre 5 en tant qu'`int` dans la variable `coordonnees`.

### listes

Une liste de taille $n$ est constituÃ©e de valeurs numÃ©rotÃ©es de 0 Ã  $n-1$. En python, on peut y stocker des valeurs de type hÃ©tÃ©rogÃ¨ne, mais on Ã©vitera autant que faire se peut. D'ailleurs le systÃ¨me de type de python nous l'impose.

Voici comment on les reconnaÃ®t:

```python
notes       : list[float]      = [15, 12, 17, 10.5, 14.5]
prenoms     : list[str]        = ["Alice", "Bob", "Clara"]
```
---

## AccÃ©der aux Ã©lÃ©ments d'une sÃ©quence

!!! danger "Indices des sÃ©quences"
    Les indices d'une sÃ©quence de taille $n$ sont numÃ©rotÃ©s de **0 Ã  $n-1$**

    Un indice est un numÃ©ro d'Ã©lÃ©ment.


Pour accÃ©der aux Ã©lÃ©ments d'une sÃ©quence, on utilise les crochets.

Pour rÃ©cupÃ©rer l'Ã©lÃ©ment numÃ©ro $i$ d'une sÃ©quence `seq`, on utilise 

```python 
seq[i]
```

Voici des exemples pour les 3 types. L'important est de remarquer que c'est toujours la mÃªme chose.

```python
mot = "Pikachu"
print(mot[0]) # "P"
print(mot[1]) # "i"
print(mot[2]) # "k"
print(mot[3]) # "a"
print(mot[4]) # "c"
print(mot[5]) # "h"
print(mot[6]) # "u"
print(mot[7]) # -> LÃ¨ve une IndexError
```

```python
personne = ("Jean", 16, "Paris")
prenom = personne[0] # "Jean" est affectÃ© Ã  la variable prenom
age    = personne[1] # 16 est affectÃ© Ã  la variable age
ville  = personne[2] # "Paris" est affectÃ© Ã  la variable ville
test   = personne[3] # -> LÃ¨ve une IndexError
```

Identiquement pour les listes:

```python
tokens = ["Une", "SÃ©quence", "est", "une", "suite", "d'Ã©lÃ©ments"]
print(tokens[0]) # "Une"
print(tokens[1]) # "SÃ©quence"
...
print(tokens[5]) # "d'Ã©lÃ©ments"
print(tokens[6]) # -> LÃ¨ve une IndexError
```

---

## Imbrication

```python
tokens = ["Une", "SÃ©quence", "est", "une", "suite", "d'Ã©lÃ©ments"]
```

`tokens[4]` vaut `"suite"`. `tokens[4]` est donc un str.

tokens[4] est donc une sÃ©quence comme les autres, qui se manipule comme les autres, avec des crochets. 

Si je veux aller chercher le caractÃ¨re numÃ©ro 2 de `tokens[4]`, je fais `tokens[4][2]`. Et j'obtiens `"i"`. 

L'imbrication n'est pas une fonctionnalitÃ© spÃ©cifique, c'est juste une consÃ©quence de la syntaxe entre crochets.

!!! question "Imbrication - Exercice guidÃ©"
    ```python
    mots = [
        ["bon", "jour"],
        ["mi", "di"],
        ["chou", "ette"]
    ]
    ```

    **Questions :**
    
    1. Combien d'Ã©lÃ©ments a `mots` ?
    2. Quel est le type complet de `mots` ?
    3. Affiche le "u" de "jour"
    4. Affiche le "m" de "mi"
    5. Affiche le "u" de "chou"
    6. Affiche la chaÃ®ne "chouette" en concatÃ©nant deux Ã©lÃ©ments de `mots`.

    **RÃ©ponses :**
    
    1. `mots` a **3 Ã©lÃ©ments** (3 listes internes)
    2. Type complet : `list[list[str]]` (liste de listes de chaÃ®nes)
    3. `print(mots[0][1][2])` â†’ affiche `"u"`
    4. `print(mots[1][0][0])` â†’ affiche `"m"`
    5. `print(mots[2][0][2])` â†’ affiche `"u"`
    6. `print(mots[2][0] + mots[2][1])` â†’ affiche `"chouette"`

!!! question "Imbrication - Exercice autonome"
    ```python
    struct = (
        "root",
        ("A", ["B", "C"], "E"),
        ("F", (4, 9), "J"),
        ("K", (2, "Mot"), ["N", "O"])
    )
    ```
    
    **Ã€ vous de faire :**
    
    1. Combien d'Ã©lÃ©ments a `struct` ?
    2. Quel est le type complet de `struct` ?
    3. Affiche "root"
    4. Affiche "J"
    5. Affiche "N"
    6. Affiche le "o" de "Mot"

    ??? success "Solutions"
        1. `struct` a **4 Ã©lÃ©ments**
        2. Type : `tuple[str, tuple[str, list[str], str], tuple[str, tuple[int, int], str], tuple[str, tuple[int, str], list[str]]]`
        3. `print(struct[0])` â†’ `"root"`
        4. `print(struct[2][2])` â†’ `"J"`
        5. `print(struct[3][2][0])` â†’ `"N"`
        6. `print(struct[3][1][1][1])` â†’ `"o"`


---
## MutabilitÃ© (capacitÃ© Ã  Ãªtre modifiÃ©)

!!! abstract "SÃ©quence immuable"
    Une sÃ©quence immuable est une sÃ©quence dont la structure de donnÃ©es ne peut pas changer. Toute opÃ©ration qui dit modifier une sÃ©quence renvoie en rÃ©alitÃ© une nouvelle sÃ©quence.

    **Les tuples et les str sont immuables**. Une fois crÃ©Ã©s, on peut les Ã©craser, mais pas les modifier.

!!! abstract "SÃ©quence mutable"
    Une sÃ©quence mutable est une sÃ©quence dont la structure de donnÃ©es peut changer. Toute opÃ©ration qui dit modifier une sÃ©quence modifie en RÃ‰ALITÃ‰ la sÃ©quence.

    **Les listes sont mutables**. Une fois crÃ©Ã©es, on peut les modifier.

### Analogie pour Comprendre

!!! tip "Analogie"
    - **Un tuple ou un str**, c'est comme un **texte Ã©crit au stylo** : pour corriger, tu dois tout rÃ©Ã©crire.
    - **Une liste**, c'est comme un texte **Ã©crit au crayon** : tu peux gommer et modifier sur place.

### ConsÃ©quences sur les str et les tuples

```python
mot = "pikachu"

mot[0] = "P" # Cette instruction renvoie l'erreur ci-dessous

>>> TypeError: 'str' object does not support item assignment
```
On ne peut pas remplacer "p" par "P". On est obligÃ© de remplacer tout le mot:

```python
mot = "Pikachu"
```

**Les consÃ©quences sont les mÃªmes sur les tuples**

```python
personne = ("Jean", 16, "Paris")

personne[0] = "Bob"  # Cette instruction renvoie l'erreur ci-dessous

>>> TypeError: 'tuple' object does not support item assignment
```

On ne peut pas remplacer "Jean" par "Bob". On est obligÃ© de remplacer tout le tuple:

```python
personne = ("Bob", 16, "Paris")
```

!!! danger "Attention"
    Ici, on utilise le mÃªme nom de variable, mais Ã  chaque fois qu'on Ã©crit `personne =`, Ã§a crÃ©e un nouvel emplacement dans la mÃ©moire, et le nom `personne` y est rattachÃ©.


### ConsÃ©quences sur les listes

```python
notes = [16, 12, 18]

notes[1] = 12.5

print(notes)

>>> [16, 12.5, 18]
```

On peut modifier la note de Bob. Ici aucun nouvel emplacement n'est crÃ©Ã© en mÃ©moire, et elle est modifiÃ©e en place.

!!! abstract "Attention"
    DÃ¨s que vous utiliserez `=` directement sur la variable, le mÃªme mÃ©canisme que prÃ©cÃ©demment s'applique. Un nouvel emplacement mÃ©moire sera crÃ©Ã©, donc vous perdrez l'avantage de la mutabilitÃ©.

---

## FonctionnalitÃ©s communes

### RÃ©cupÃ©rer le nombre d'Ã©lÃ©ments

On utilise la fonction `len()`, comme longueur en anglais.

```python
a = [1, 34, 56]
print(len(a))

>>> 3
```

```python
a = (1, 25, 42, 57)
print(len(a))

>>> 4
```

```python
a = "abc"
print(len(a))

>>> 3
```

### Appartenance

On utilise la syntaxe `in` et `not in`. Ce sont des opÃ©rateurs boolÃ©ens comme les autres.

```python
a = [1, 2, 3]
print(3 in a)  # True
print(4 in a)  # False
print(3 not in a)  # False
print(4 not in a)  # True
```

### ConcatÃ©nation (+)

```python
a = [1, 2, 3]
b = [4, 5, 6]
c = a + b
print(c)

>>> [1, 2, 3, 4, 5, 6]
```

### RÃ©pÃ©tition (*)

```python
a = (1, 2, 3)
b = a * 3
print(b)

>>> (1, 2, 3, 1, 2, 3, 1, 2, 3)
```

### Indexation ([])  (vu au dÃ©but du cours)

```python
a = "xyz"
b = a[1]
print(b)

>>> y
```

### Slice ([:])

Les slices permettent de prendre une partie d'une sÃ©quence.

```python
t = ("A", "B", "C", "D", "E", "F")
b = t[1:4]  # de 1 Ã  4 EXCLUS, donc de 1 Ã  3
print(b)
>>> ("B", "C", "D")
```

```python
a = "ABCDEF"
b = a[3:]  # de 3 Ã  la fin (rien aprÃ¨s le :)
print(b)
>>> "DEF"
```

```python
lst = ["A", "B", "C", "D", "E", "F"]
b = lst[:3]  # Du dÃ©but (rien avant le :) Ã  3 EXCLUS, donc de 0 Ã  2
print(b)
>>> ['A', 'B', 'C']
```

!!! tip "Slices avancÃ©s (optionnel)"
    On peut aussi utiliser un **pas** (step) pour sauter des Ã©lÃ©ments :
    
    ```python
    # Prendre un Ã©lÃ©ment sur deux
    lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    print(lst[::2])  # DÃ©but:Fin:Pas
    >>> [0, 2, 4, 6, 8]
    
    # Inverser une sÃ©quence
    mot = "Python"
    print(mot[::-1])
    >>> "nohtyP"
    ```

---

## âš ï¸ Erreurs FrÃ©quentes

Voici les erreurs les plus courantes avec les sÃ©quences :

### Erreur 1 : Index hors limites

```python
# âŒ ERREUR
lst = [1, 2, 3]
print(lst[5])  # IndexError: list index out of range

# âœ… CORRECT
print(lst[2])  # Dernier Ã©lÃ©ment (indice = taille - 1)
```

!!! tip "Astuce"
    L'indice maximum est toujours `len(seq) - 1` !

### Erreur 2 : Modifier un immuable

```python
# âŒ ERREUR
mot = "test"
mot[0] = "T"  # TypeError: 'str' object does not support item assignment

# âœ… CORRECT
mot = "Test"  # CrÃ©er un nouveau str
```

```python
# âŒ ERREUR
coords = (5, 10)
coords[0] = 3  # TypeError: 'tuple' object does not support item assignment

# âœ… CORRECT
coords = (3, 10)  # CrÃ©er un nouveau tuple
```

### Erreur 3 : Confusion sur les slices

```python
# âš ï¸ ATTENTION
lst = [0, 1, 2, 3, 4]
print(lst[1:4])  
>>> [1, 2, 3]  # Pas [1, 2, 3, 4] !

# L'indice de fin est EXCLUS
```

!!! tip "MnÃ©motechnique"
    `[dÃ©but:fin]` signifie : **de dÃ©but INCLUS Ã  fin EXCLUS**

### Erreur 4 : Confondre indice et valeur

```python
# âŒ ERREUR
notes = [15, 12, 18]
print(notes[15])  # IndexError (15 est une valeur, pas un indice !)

# âœ… CORRECT
print(notes[0])  # 15 (accÃ©der par l'indice)
print(15 in notes)  # True (tester l'appartenance d'une valeur)
```

### Erreur 5 : Oublier que `len()` compte Ã  partir de 1

```python
lst = [10, 20, 30]
print(len(lst))  # 3

# âŒ ERREUR
print(lst[len(lst)])  # IndexError: list index out of range

# âœ… CORRECT
print(lst[len(lst) - 1])  # 30 (dernier Ã©lÃ©ment)
```

---

## ğŸ“š Pour Aller Plus Loin

### DÃ©structuration (Hors Programme)

!!! abstract "DÃ©construction"
    Certains d'entre vous vont tomber sur cette syntaxe, donc je prÃ©fÃ¨re l'expliquer:

    ```python
    a, b, c = 3, 7, 9
    ```

    Ce qui signifie que les variables `a`, `b` et `c` seront affectÃ©es respectivement aux valeurs 3, 7 et 9.

    On appelle Ã§a une dÃ©structuration ou dÃ©construction.

    La forme du tuple `(3, 7, 9)` est comparÃ©e Ã  la forme du tuple `(a, b, c)` et les valeurs 3, 7 et 9 seront affectÃ©es respectivement aux variables a, b et c.

    **Exemple pratique :**
    ```python
    personne = ("Alice", 25, "Paris")
    nom, age, ville = personne
    print(nom)    # "Alice"
    print(age)    # 25
    print(ville)  # "Paris"
    ```

    **Ã‡a n'est que la partie Ã©mergÃ©e de l'iceberg.**

    ```python
    a, *b = 3, 7, 9
    ```
    Ce code va affecter `a` Ã  3, et le reste (*) dans `b`, sous forme de liste `[7, 9]`

    ```python
    premier, *milieu, dernier = [1, 2, 3, 4, 5]
    print(premier)  # 1
    print(milieu)   # [2, 3, 4]
    print(dernier)  # 5
    ```

    Ce n'est pas une astuce de langage, c'est un outil trÃ¨s puissant dans la rÃ©solution de problÃ¨mes.

---

## ğŸ“ RÃ©sumÃ©

| Type | Exemple | Mutable ? | Usage |
|------|---------|-----------|-------|
| **str** | `"Hello"` | âŒ Non | Texte |
| **tuple** | `(1, 2, 3)` | âŒ Non | DonnÃ©es fixes |
| **list** | `[1, 2, 3]` | âœ… Oui | DonnÃ©es modifiables |

**OpÃ©rations communes :**
- AccÃ¨s : `seq[i]`
- Longueur : `len(seq)`
- Appartenance : `x in seq`
- Slice : `seq[dÃ©but:fin]`
- ConcatÃ©nation : `seq1 + seq2`
- RÃ©pÃ©tition : `seq * n`

**Ã€ retenir :**
- Les indices commencent Ã  **0**
- Le dernier indice est **`len(seq) - 1`**
- Les slices excluent l'indice de fin
- Seules les listes sont modifiables



---
---

## Exercices sur les sÃ©quences en Python

!!! question "Exercice 1 : CrÃ©ation et accÃ¨s"
    1. CrÃ©er une liste `temperatures` contenant les tempÃ©ratures suivantes : 18.5, 20.0, 19.3, 21.2, 17.8
    2. Afficher la premiÃ¨re tempÃ©rature
    3. Afficher la derniÃ¨re tempÃ©rature
    4. Afficher la tempÃ©rature du milieu (3Ã¨me Ã©lÃ©ment)

!!! question "Exercice 2 : Longueur et indices"
    1. CrÃ©er un tuple `jours` contenant : "lundi", "mardi", "mercredi", "jeudi", "vendredi"
    2. Afficher le nombre de jours dans ce tuple
    3. Afficher le jour Ã  l'indice 2
    4. Afficher le dernier jour en utilisant un indice nÃ©gatif

!!! question "Exercice 3 : Slicing (tranches)"
    Soit la liste `notes = [12, 15, 8, 14, 16, 11, 13]`
    1. Extraire les 3 premiÃ¨res notes
    2. Extraire les 2 derniÃ¨res notes
    3. Extraire les notes de l'indice 2 Ã  4 (inclus)
    4. Extraire toutes les notes sauf la premiÃ¨re et la derniÃ¨re

!!! question "Exercice 4 : Modification de listes"
    1. CrÃ©er une liste `fruits = ["pomme", "banane", "orange"]`
    2. Remplacer "banane" par "kiwi"
    3. Ajouter "fraise" Ã  la fin de la liste avec `.append()`
    4. Afficher la liste finale

!!! question "Exercice 5 : ConcatÃ©nation"
    1. CrÃ©er deux listes : `nombres1 = [1, 2, 3]` et `nombres2 = [4, 5, 6]`
    2. CrÃ©er une nouvelle liste `tous_nombres` qui combine les deux listes
    3. Afficher le rÃ©sultat

!!! question "Exercice 6 : RÃ©pÃ©tition"
    1. CrÃ©er une liste contenant 5 fois le nombre 0
    2. CrÃ©er un tuple contenant 3 fois la chaÃ®ne "NSI"
    3. Afficher les rÃ©sultats

!!! question "Exercice 7 : Test d'appartenance"
    Soit `prenoms = ["Alice", "Bob", "Charlie", "David"]`
    1. VÃ©rifier si "Bob" est dans la liste
    2. VÃ©rifier si "Eve" est dans la liste
    3. Afficher les rÃ©sultats avec des messages explicites

!!! question "Exercice 8 : Min, max, sum"
    Soit `scores = [85, 92, 78, 95, 88]`
    1. Afficher le score minimum
    2. Afficher le score maximum
    3. Calculer et afficher la somme des scores
    4. Calculer et afficher la moyenne des scores

!!! question "Exercice 9 : ImmuabilitÃ© des tuples"
    1. CrÃ©er un tuple `coordonnees = (3, 7)`
    2. Essayer de modifier le premier Ã©lÃ©ment (observer l'erreur)
    3. CrÃ©er un nouveau tuple `nouvelles_coord` avec des valeurs diffÃ©rentes
    4. Expliquer dans un commentaire pourquoi on ne peut pas modifier un tuple

!!! question "Exercice 10 : Mini-projet - Bulletin de notes"
    CrÃ©er un programme qui :
    1. Stocke dans une liste les notes suivantes : 14, 16, 12, 15, 13
    2. Stocke dans un tuple les coefficients : 1, 2, 1, 1, 2
    3. Calcule la moyenne pondÃ©rÃ©e (sans boucle, en accÃ©dant directement aux indices)
    - Formule : (note0Ã—coef0 + note1Ã—coef1 + ...) / (somme des coefficients)
    4. Affiche la moyenne avec un message appropriÃ©


## Fonctions avec des sÃ©quences


!!! hint "Utiliser les doctests (tests unitaires automatiques)"

    Mettez le code suivant Ã  la fin de votre fichier:

    ```python
    if __name__ == "__main__":
        import doctest
        doctest.testmod()  # ExÃ©cute tous les doctests
    ```

    Il permet d'exÃ©cuter automatiquement les doctests lorsque vous exÃ©cutez le programme python.

    Les doctests sont les instructions prÃ©cÃ©dÃ©es de `>>> ` dans la docstring.

    Le code suivant veut dire que quand on exÃ©cutera premier_element([18.5, 20.0, 19.3]), on attend que la fonction renvoie 18.5

    ```python
    >>> premier_element([18.5, 20.0, 19.3])
    18.5
    ```

    Si le test est passant (il marche), alors python ne dira rien du tout. Sinon il rÃ¢le.

    Dans le code que je vous fournis, j'annule l'exÃ©cution des doctests en indiquant `# doctest: +SKIP`

    Ca vous permet de copier coller tout le texte d'un exercice, et d'activer les doctests de la fonction sur laquelle vous travaillez en supprimant  `# doctest: +SKIP`



!!! question "Exercice 1 : Fonctions d'accÃ¨s aux Ã©lÃ©ments"
    Ã‰crire les fonctions suivantes :

    ```python
    def premier_element(sequence: list) -> int | float | str:
        """Renvoie le premier Ã©lÃ©ment d'une sÃ©quence
        
        >>> premier_element([18.5, 20.0, 19.3])     # doctest: +SKIP
        18.5
        >>> premier_element(['a', 'b', 'c'])     # doctest: +SKIP
        'a'
        """
        pass

    def dernier_element(sequence: list) -> int | float | str:
        """Renvoie le dernier Ã©lÃ©ment
        
        >>> dernier_element([18.5, 20.0, 19.3])     # doctest: +SKIP
        19.3
        >>> dernier_element([1, 2, 3, 4, 5])     # doctest: +SKIP
        5
        """
        pass

    def element_milieu(sequence: list) -> int | float | str:
        """Renvoie l'Ã©lÃ©ment du milieu (longueur impaire)
        
        >>> element_milieu([18.5, 20.0, 19.3, 21.2, 17.8])     # doctest: +SKIP
        19.3
        >>> element_milieu([1, 2, 3])     # doctest: +SKIP
        2
        """
        pass
    ```

!!! question "Exercice 2 : Fonctions de vÃ©rification"
    Ã‰crire les fonctions suivantes :

    ```python
    def est_vide(sequence: list | tuple) -> bool:
        """Renvoie True si la sÃ©quence est vide, False sinon
        
        >>> est_vide([])     # doctest: +SKIP
        True
        >>> est_vide([1, 2, 3])     # doctest: +SKIP
        False
        >>> est_vide(())     # doctest: +SKIP
        True
        """
        pass

    def longueur_paire(sequence: list | tuple) -> bool:
        """Renvoie True si la longueur est paire
        
        >>> longueur_paire([1, 2, 3, 4])     # doctest: +SKIP
        True
        >>> longueur_paire([1, 2, 3])     # doctest: +SKIP
        False
        >>> longueur_paire([])     # doctest: +SKIP
        True
        """
        pass

    def contient(sequence: list | tuple, element: int | float | str) -> bool:
        """Renvoie True si l'Ã©lÃ©ment est dans la sÃ©quence
        
        >>> contient([1, 2, 3], 2)     # doctest: +SKIP
        True
        >>> contient([1, 2, 3], 5)     # doctest: +SKIP
        False
        >>> contient(['a', 'b', 'c'], 'b')     # doctest: +SKIP
        True
        """
        pass
    ```

!!! question "Exercice 3 : Fonctions de dÃ©coupage"
    Ã‰crire les fonctions suivantes :

    ```python
    def trois_premiers(sequence: list) -> list:
        """Renvoie les 3 premiers Ã©lÃ©ments
        
        >>> trois_premiers([12, 15, 8, 14, 16, 11, 13])     # doctest: +SKIP
        [12, 15, 8]
        >>> trois_premiers([1, 2, 3, 4, 5])     # doctest: +SKIP
        [1, 2, 3]
        """
        pass

    def deux_derniers(sequence: list) -> list:
        """Renvoie les 2 derniers Ã©lÃ©ments
        
        >>> deux_derniers([12, 15, 8, 14, 16, 11, 13])     # doctest: +SKIP
        [11, 13]
        >>> deux_derniers([1, 2, 3, 4, 5])     # doctest: +SKIP
        [4, 5]
        """
        pass

    def sans_extremes(sequence: list) -> list:
        """Renvoie la sÃ©quence sans le premier et le dernier Ã©lÃ©ment
        
        >>> sans_extremes([12, 15, 8, 14, 16, 11, 13])     # doctest: +SKIP
        [15, 8, 14, 16, 11]
        >>> sans_extremes([1, 2, 3, 4])     # doctest: +SKIP
        [2, 3]
        """
        pass
    ```

!!! question "Exercice 4 : Fonctions de statistiques simples"
    Ã‰crire les fonctions suivantes :

    ```python
    def minimum(sequence: list[int | float]) -> int | float:
        """Renvoie le plus petit Ã©lÃ©ment
        
        >>> minimum([85, 92, 78, 95, 88])     # doctest: +SKIP
        78
        >>> minimum([3.5, 2.1, 4.8])     # doctest: +SKIP
        2.1
        """
        pass

    def maximum(sequence: list[int | float]) -> int | float:
        """Renvoie le plus grand Ã©lÃ©ment
        
        >>> maximum([85, 92, 78, 95, 88])     # doctest: +SKIP
        95
        >>> maximum([3.5, 2.1, 4.8])     # doctest: +SKIP
        4.8
        """
        pass

    def etendue(sequence: list[int | float]) -> int | float:
        """Renvoie la diffÃ©rence entre le max et le min
        
        >>> etendue([85, 92, 78, 95, 88])     # doctest: +SKIP
        17
        >>> etendue([10, 20, 30])     # doctest: +SKIP
        20
        """
        pass

    def moyenne(sequence: list[int | float]) -> float:
        """Calcule la moyenne des Ã©lÃ©ments
        
        >>> moyenne([85, 92, 78, 95, 88])     # doctest: +SKIP
        87.6
        >>> moyenne([10, 20, 30])     # doctest: +SKIP
        20.0
        """
        pass
    ```

!!! question "Exercice 5 : Fonctions de crÃ©ation"
    Ã‰crire les fonctions suivantes :

    ```python
    def creer_liste_zeros(n: int) -> list[int]:
        """Renvoie une liste de n zÃ©ros
        
        >>> creer_liste_zeros(5)     # doctest: +SKIP
        [0, 0, 0, 0, 0]
        >>> creer_liste_zeros(3)     # doctest: +SKIP
        [0, 0, 0]
        """
        pass

    def creer_liste_constante(n: int, valeur: int | float | str) -> list:
        """Renvoie une liste de n fois la mÃªme valeur
        
        >>> creer_liste_constante(4, 7)     # doctest: +SKIP
        [7, 7, 7, 7]
        >>> creer_liste_constante(3, 'NSI')     # doctest: +SKIP
        ['NSI', 'NSI', 'NSI']
        """
        pass

    def concatener(seq1: list, seq2: list) -> list:
        """Renvoie la concatÃ©nation de deux sÃ©quences
        
        >>> concatener([1, 2, 3], [4, 5, 6])     # doctest: +SKIP
        [1, 2, 3, 4, 5, 6]
        >>> concatener(['a', 'b'], ['c', 'd'])     # doctest: +SKIP
        ['a', 'b', 'c', 'd']
        """
        pass
    ```

!!! question "Exercice 6 : Fonctions de modification"
    Ã‰crire les fonctions suivantes :

    ```python
    def remplacer_premier(liste: list, nouvelle_valeur: int | float | str) -> list:
        """Remplace le premier Ã©lÃ©ment et renvoie la liste modifiÃ©e
        
        >>> remplacer_premier([1, 2, 3], 10)     # doctest: +SKIP
        [10, 2, 3]
        >>> remplacer_premier(['a', 'b', 'c'], 'z')     # doctest: +SKIP
        ['z', 'b', 'c']
        """
        pass

    def remplacer_dernier(liste: list, nouvelle_valeur: int | float | str) -> list:
        """Remplace le dernier Ã©lÃ©ment
        
        >>> remplacer_dernier([1, 2, 3], 10)     # doctest: +SKIP
        [1, 2, 10]
        >>> remplacer_dernier(['a', 'b', 'c'], 'z')     # doctest: +SKIP
        ['a', 'b', 'z']
        """
        pass

    def ajouter_element(liste: list, element: int | float | str) -> list:
        """Ajoute un Ã©lÃ©ment Ã  la fin et renvoie la liste
        
        >>> ajouter_element([1, 2, 3], 4)     # doctest: +SKIP
        [1, 2, 3, 4]
        >>> ajouter_element(['a', 'b'], 'c')     # doctest: +SKIP
        ['a', 'b', 'c']
        """
        pass
    ```

!!! question "Exercice 7 : Fonctions de comparaison"
    Ã‰crire les fonctions suivantes :

    ```python
    def meme_longueur(seq1: list | tuple, seq2: list | tuple) -> bool:
        """Renvoie True si les deux sÃ©quences ont la mÃªme longueur
        
        >>> meme_longueur([1, 2, 3], [4, 5, 6])     # doctest: +SKIP
        True
        >>> meme_longueur([1, 2], [3, 4, 5])     # doctest: +SKIP
        False
        >>> meme_longueur((1, 2), [3, 4])     # doctest: +SKIP
        True
        """
        pass

    def plus_longue(seq1: list, seq2: list) -> list:
        """Renvoie la sÃ©quence la plus longue
        
        >>> plus_longue([1, 2, 3], [4, 5])     # doctest: +SKIP
        [1, 2, 3]
        >>> plus_longue([1], [2, 3, 4, 5])     # doctest: +SKIP
        [2, 3, 4, 5]
        """
        pass

    def ont_element_commun(seq1: list, seq2: list) -> bool:
        """Renvoie True si au moins un Ã©lÃ©ment est prÃ©sent dans les deux sÃ©quences
        
        >>> ont_element_commun([1, 2, 3], [3, 4, 5])     # doctest: +SKIP
        True
        >>> ont_element_commun([1, 2], [3, 4])     # doctest: +SKIP
        False
        >>> ont_element_commun(['a', 'b'], ['b', 'c'])     # doctest: +SKIP
        True
        """
        pass
    ```

!!! question "Exercice 8 : Fonctions avec indices"
    Ã‰crire les fonctions suivantes :

    ```python
    def element_a_position(sequence: list, position: int) -> int | float | str | None:
        """Renvoie l'Ã©lÃ©ment Ã  la position donnÃ©e, None si position invalide
        
        >>> element_a_position([10, 20, 30, 40], 2)     # doctest: +SKIP
        30
        >>> element_a_position([10, 20, 30], 5)     # doctest: +SKIP
        
        >>> element_a_position(['a', 'b', 'c'], 0)     # doctest: +SKIP
        'a'
        """
        pass

    def echanger_extremes(liste: list) -> list:
        """Ã‰change le premier et le dernier Ã©lÃ©ment
        
        >>> echanger_extremes([1, 2, 3, 4, 5])     # doctest: +SKIP
        [5, 2, 3, 4, 1]
        >>> echanger_extremes(['a', 'b', 'c'])     # doctest: +SKIP
        ['c', 'b', 'a']
        """
        pass

    def inverser_paire(liste: list) -> list:
        """Inverse les deux premiers Ã©lÃ©ments
        
        >>> inverser_paire([1, 2, 3, 4])     # doctest: +SKIP
        [2, 1, 3, 4]
        >>> inverser_paire(['a', 'b', 'c'])     # doctest: +SKIP
        ['b', 'a', 'c']
        """
        pass
    ```

!!! question "Exercice 9 : Fonctions de validation"
    Ã‰crire les fonctions suivantes :

    ```python
    def tous_positifs(sequence: list[int | float]) -> bool:
        """VÃ©rifie que tous les nombres sont positifs
        
        >>> tous_positifs([1, 2, 3, 4])     # doctest: +SKIP
        True
        >>> tous_positifs([1, -2, 3])     # doctest: +SKIP
        False
        >>> tous_positifs([0, 5, 10])     # doctest: +SKIP
        True
        """
        pass

    def au_moins_un_negatif(sequence: list[int | float]) -> bool:
        """VÃ©rifie s'il y a au moins un nombre nÃ©gatif
        
        >>> au_moins_un_negatif([5, -3, 12, 8])     # doctest: +SKIP
        True
        >>> au_moins_un_negatif([1, 2, 3])     # doctest: +SKIP
        False
        >>> au_moins_un_negatif([0, -1, 5])     # doctest: +SKIP
        True
        """
        pass

    def dans_intervalle(sequence: list[int | float], min_val: int | float, max_val: int | float) -> bool:
        """VÃ©rifie que tous les Ã©lÃ©ments sont entre min_val et max_val
        
        >>> dans_intervalle([5, 8, 12, 15], 0, 20)     # doctest: +SKIP
        True
        >>> dans_intervalle([5, -3, 12], 0, 20)     # doctest: +SKIP
        False
        >>> dans_intervalle([10, 12, 15], 10, 15)     # doctest: +SKIP
        True
        """
        pass
    ```


!!! question "Exercice 11 : Fonctions avancÃ©es - CoordonnÃ©es 2D"

    CrÃ©er un systÃ¨me de gestion de points dans un plan :

    ```python
    def creer_point(x: float, y: float) -> tuple[float, float]:
        """CrÃ©e un point sous forme de tuple (x, y)
        
        >>> creer_point(3.0, 4.0)     # doctest: +SKIP
        (3.0, 4.0)
        >>> creer_point(-2.5, 1.5)     # doctest: +SKIP
        (-2.5, 1.5)
        """
        pass

    def abscisse(point: tuple[float, float]) -> float:
        """Renvoie l'abscisse du point
        
        >>> abscisse((3.0, 4.0))     # doctest: +SKIP
        3.0
        >>> abscisse((-2.5, 1.5))     # doctest: +SKIP
        -2.5
        """
        pass

    def ordonnee(point: tuple[float, float]) -> float:
        """Renvoie l'ordonnÃ©e du point
        
        >>> ordonnee((3.0, 4.0))     # doctest: +SKIP
        4.0
        >>> ordonnee((-2.5, 1.5))     # doctest: +SKIP
        1.5
        """
        pass

    def distance_origine(point: tuple[float, float]) -> float:
        """Calcule la distance du point Ã  l'origine
        
        >>> distance_origine((3.0, 4.0))     # doctest: +SKIP
        5.0
        >>> distance_origine((0.0, 0.0))     # doctest: +SKIP
        0.0
        """
        # Utiliser la formule: racine(xÂ² + yÂ²)
        pass

    def milieu(point1: tuple[float, float], point2: tuple[float, float]) -> tuple[float, float]:
        """Calcule le point milieu entre deux points
        
        >>> milieu((0.0, 0.0), (4.0, 6.0))     # doctest: +SKIP
        (2.0, 3.0)
        >>> milieu((1.0, 2.0), (3.0, 4.0))     # doctest: +SKIP
        (2.0, 3.0)
        """
        pass

    def creer_rectangle(point1: tuple[float, float], point2: tuple[float, float]) -> list[tuple[float, float]]:
        """CrÃ©e une liste de 4 points formant un rectangle
        
        >>> creer_rectangle((0.0, 0.0), (2.0, 3.0))     # doctest: +SKIP
        [(0.0, 0.0), (2.0, 0.0), (2.0, 3.0), (0.0, 3.0)]
        """
        # Les deux points donnÃ©s sont des coins opposÃ©s
        pass
    ```

!!! question "Exercice 12 : Fonctions de formatage"

    Ã‰crire les fonctions suivantes :

    ```python
    def formater_liste(sequence: list) -> str:
        """Renvoie une chaÃ®ne du type: '[elem1, elem2, elem3]'
        
        >>> formater_liste([1, 2, 3])     # doctest: +SKIP
        '[1, 2, 3]'
        >>> formater_liste(['a', 'b'])     # doctest: +SKIP
        '[a, b]'
        """
        pass

    def creer_email(prenom: str, nom: str, domaine: str) -> str:
        """CrÃ©e une adresse email
        
        >>> creer_email("Jean", "Dupont", "lycee.fr")     # doctest: +SKIP
        'jean.dupont@lycee.fr'
        >>> creer_email("Marie", "Martin", "ecole.org")     # doctest: +SKIP
        'marie.martin@ecole.org'
        """
        # Penser Ã  utiliser .lower() pour mettre en minuscules
        pass
    ```

!!! question "Exercice 13 : Fonctions avec tuples de taille fixe"

    ```python
    def creer_date(jour: int, mois: int, annee: int) -> tuple[int, int, int]:
        """CrÃ©e un tuple reprÃ©sentant une date
        
        >>> creer_date(15, 3, 2024)     # doctest: +SKIP
        (15, 3, 2024)
        >>> creer_date(1, 1, 2000)     # doctest: +SKIP
        (1, 1, 2000)
        """
        pass

    def jour_de(date: tuple[int, int, int]) -> int:
        """Extrait le jour d'une date
        
        >>> jour_de((15, 3, 2024))     # doctest: +SKIP
        15
        >>> jour_de((1, 12, 2023))     # doctest: +SKIP
        1
        """
        pass

    def mois_de(date: tuple[int, int, int]) -> int:
        """Extrait le mois d'une date
        
        >>> mois_de((15, 3, 2024))     # doctest: +SKIP
        3
        >>> mois_de((1, 12, 2023))     # doctest: +SKIP
        12
        """
        pass

    def annee_de(date: tuple[int, int, int]) -> int:
        """Extrait l'annÃ©e d'une date
        
        >>> annee_de((15, 3, 2024))     # doctest: +SKIP
        2024
        >>> annee_de((1, 12, 2023))     # doctest: +SKIP
        2023
        """
        pass

    def date_valide(date: tuple[int, int, int]) -> bool:
        """VÃ©rifie si une date est valide (jours entre 1-31, mois entre 1-12)
        
        >>> date_valide((15, 3, 2024))     # doctest: +SKIP
        True
        >>> date_valide((32, 1, 2024))     # doctest: +SKIP
        False
        >>> date_valide((15, 13, 2024))     # doctest: +SKIP
        False
        >>> date_valide((0, 5, 2024))     # doctest: +SKIP
        False
        """
        pass
    ```

