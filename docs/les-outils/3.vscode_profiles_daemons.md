# VSCode : Profils, Daemons et Gestion de la RAM

## ğŸ¯ Le ProblÃ¨me

**Situation :** Tu installes 20 extensions dans VSCode (Python, Rust, Elm, C++, etc.)  
**RÃ©sultat :** VSCode bouffe 4 GB de RAM et rame ğŸŒ

**Pourquoi ?** Les **daemons** lancÃ©s par chaque extension tournent en permanence !

---

## 1. C'est Quoi un Daemon ?

### DÃ©finition Simple

**Daemon** (ou dÃ©mon) = **Programme qui tourne en arriÃ¨re-plan en permanence**

**CaractÃ©ristiques :**

- Lance au dÃ©marrage
- Tourne sans interface visible
- Attend des requÃªtes
- Consomme de la RAM mÃªme si tu ne l'utilises pas

### Analogie

**Un daemon, c'est comme un serveur dans un restaurant :**

- Il est toujours lÃ , mÃªme s'il n'y a pas de clients
- Il attend qu'on lui demande quelque chose
- Il reste debout toute la journÃ©e (= consomme de la RAM)

### Exemples de Daemons SystÃ¨me

| Daemon | RÃ´le |
|--------|------|
| `sshd` | Serveur SSH (connexions distantes) |
| `httpd` | Serveur web Apache |
| `systemd` | Gestion des services Linux |
| `Docker daemon` | Gestion des conteneurs |

---

## 2. Les Daemons dans VSCode

### Pourquoi les Extensions Lancent des Daemons ?

**Les extensions de langages ont besoin de :**

1. **Analyser ton code en temps rÃ©el**
2. **Fournir l'autocomplÃ©tion**
3. **DÃ©tecter les erreurs**
4. **Formater le code**
5. **Naviguer dans les dÃ©finitions**

**Pour Ãªtre rÃ©actives, elles lancent un daemon qui :**

- Lit ton code
- L'analyse en permanence
- Garde le rÃ©sultat en mÃ©moire
- RÃ©pond instantanÃ©ment Ã  tes demandes

### Exemples de Daemons d'Extensions

| Extension | Daemon | RAM |
|-----------|--------|-----|
| **Python** | Pylance Language Server | ~200 MB |
| **Rust** | rust-analyzer | ~300 MB |
| **C/C++** | clangd | ~150 MB |
| **Elm** | Elm Language Server | ~100 MB |
| **Java** | Eclipse JDT LS | ~500 MB |
| **TypeScript** | tsserver | ~250 MB |

**Total si tout installÃ© : 1.5 GB+ de RAM !** ğŸ’¥

### Visualiser les Daemons

**Dans VSCode :**

1. Ouvre la palette : `Ctrl+Shift+P`
2. Tape : "Developer: Show Running Extensions"
3. Regarde la colonne "Activation Time" et "Memory"

**En ligne de commande :**
```bash
# Linux/Mac
ps aux | grep -E "python|rust-analyzer|clangd|elm"

# Windows
tasklist | findstr "python rust clangd"
```

---

## 3. Pourquoi CrÃ©er des Profils par Langage

### Le ProblÃ¨me Sans Profils

```
VSCode avec TOUTES les extensions
â”œâ”€â”€ Python extension â†’ lance python daemon (200 MB)
â”œâ”€â”€ Rust extension â†’ lance rust-analyzer (300 MB)
â”œâ”€â”€ Elm extension â†’ lance elm daemon (100 MB)
â”œâ”€â”€ C++ extension â†’ lance clangd (150 MB)
â””â”€â”€ ... 15 autres extensions

Total RAM : 2-4 GB
```

**MÃªme si tu codes en Python, les daemons Rust/Elm/C++ tournent quand mÃªme !**

### La Solution : Profils

**Un profil = un VSCode avec seulement les extensions nÃ©cessaires**

```
Profil Python
â”œâ”€â”€ Python extension â†’ 200 MB
â””â”€â”€ Extensions gÃ©nÃ©rales (Git, etc.)
Total RAM : 400 MB

Profil Rust
â”œâ”€â”€ Rust extension â†’ 300 MB
â””â”€â”€ Extensions gÃ©nÃ©rales
Total RAM : 500 MB
```

**Ã‰conomie : 1.5-3 GB de RAM par profil !** ğŸ’°

---

## 4. CrÃ©er des Profils dans VSCode

### MÃ©thode Graphique

**Ã‰tape 1 : Ouvrir le menu des profils**

1. Clique sur l'icÃ´ne âš™ï¸ (engrenage) en bas Ã  gauche
2. SÃ©lectionne "Profiles"
3. Clique sur "Create Profile"

**Ã‰tape 2 : Configurer le profil**
```
Nom : Python Development
Copier depuis : Default Profile (ou None)
```

**Ã‰tape 3 : Activer le profil**
- Le profil s'active automatiquement aprÃ¨s crÃ©ation
- Tu peux switcher avec : âš™ï¸ â†’ Profiles â†’ SÃ©lectionne un profil

**Ã‰tape 4 : Installer uniquement les extensions nÃ©cessaires**
```
Pour Python :
âœ… Python
âœ… Pylance
âœ… Python Debugger
âœ… Git (gÃ©nÃ©ral)
âœ… GitLens (gÃ©nÃ©ral)
âŒ Rust-analyzer (pas besoin)
âŒ Elm (pas besoin)
```

### MÃ©thode Ligne de Commande

```bash
# Lancer VSCode avec un profil spÃ©cifique
code --profile "Python Development"

# CrÃ©er un profil vide
code --profile "Rust Development" --extensions-dir ~/.vscode-rust/extensions
```

### Structure RecommandÃ©e

```
Profils Ã  crÃ©er :
â”œâ”€â”€ Default (minimal, sans language servers)
â”œâ”€â”€ Python Development
â”œâ”€â”€ Rust Development
â”œâ”€â”€ Web Development (HTML/CSS/JS)
â”œâ”€â”€ Elm Development
â”œâ”€â”€ C/C++ Development
â””â”€â”€ Ã‰criture (Markdown, pas de code)
```

---

## 5. Comment Fonctionnent les Language Servers

### Architecture Client-Serveur

```
VSCode (Client)
    â†“ demande d'autocomplÃ©tion
Language Server (Daemon)
    â†“ analyse le code
    â†“ retourne les suggestions
VSCode affiche les suggestions
```

### Le Protocol LSP (Language Server Protocol)

**InventÃ© par Microsoft pour VSCode**

**Avant LSP :**
```
Chaque Ã©diteur Ã— Chaque langage = N Ã— M implÃ©mentations
Vim + Python, Vim + Rust, Emacs + Python, Emacs + Rust...
```

**Avec LSP :**
```
1 Language Server par langage
Ã— 
N Ã©diteurs qui parlent LSP
= N + M implÃ©mentations seulement !
```

**Liste de Language Servers :**
| Langage | Language Server |
|---------|-----------------|
| Python | Pylance, Pyright |
| Rust | rust-analyzer |
| C/C++ | clangd, ccls |
| JavaScript/TypeScript | tsserver |
| Elm | elm-language-server |
| Go | gopls |
| Java | Eclipse JDT LS |

---

## 6. CrÃ©er Ton Propre Daemon (Exemple AvancÃ©)

### Pourquoi CrÃ©er un Daemon ?

**Cas d'usage :**
- Surveiller des fichiers
- Compiler automatiquement
- Lancer des tests en continu
- Analyser le code custom

### Exemple Simple en Python

```python
# mon_daemon.py
import time
import os
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class MonDaemon(FileSystemEventHandler):
    def on_modified(self, event):
        if event.src_path.endswith('.elm'):
            print(f"Fichier modifiÃ© : {event.src_path}")
            os.system(f"elm make {event.src_path}")

if __name__ == "__main__":
    print("ğŸ”„ Daemon Elm lancÃ©...")
    
    observer = Observer()
    observer.schedule(MonDaemon(), path="./src", recursive=True)
    observer.start()
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    
    observer.join()
```

**Lancer le daemon :**
```bash
python mon_daemon.py &  # Le & lance en arriÃ¨re-plan
```

### IntÃ©gration dans VSCode

**CrÃ©er une tÃ¢che VSCode (`.vscode/tasks.json`) :**
```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Start Elm Daemon",
      "type": "shell",
      "command": "python",
      "args": ["${workspaceFolder}/mon_daemon.py"],
      "isBackground": true,
      "problemMatcher": []
    }
  ]
}
```

**Lancer avec :** `Ctrl+Shift+P` â†’ "Tasks: Run Task" â†’ "Start Elm Daemon"

---

## 7. GÃ©rer les Daemons qui Consomment Trop

### Diagnostiquer

**1. VSCode Task Manager**
```
Ctrl+Shift+P â†’ "Developer: Open Process Explorer"
```

### DÃ©sactiver Temporairement des Extensions

**Sans changer de profil :**
1. `Ctrl+Shift+X` â†’ Extensions
2. Clique sur l'engrenage de l'extension
3. "Disable (Workspace)" â†’ dÃ©sactive uniquement pour ce projet

---

## 9. Bonnes Pratiques

### âœ… Ã€ Faire

1. **Un profil par langage principal**
   - Python, Elm, Rust, Web, etc.

2. **Profil minimal pour l'Ã©criture**
   - Markdown, notes, docs
   - Pas de language server = rapide

3. **DÃ©sactiver les extensions inutilisÃ©es**
   - Pas besoin de Rust si tu codes en Python

4. **Fermer VSCode entre les projets**
   - LibÃ¨re la RAM des daemons

5. **Surveiller la RAM rÃ©guliÃ¨rement**
   - Process Explorer de VSCode (ui lui mÃªme consomme de la RAM, alors ne pas laisser ouvert)

### âŒ Ã€ Ã‰viter

1. **Installer toutes les extensions "au cas oÃ¹"**
   - Elles tournent mÃªme inutilisÃ©es

2. **Laisser VSCode ouvert H24**
   - Les daemons accumulent la RAM

3. **Ouvrir plusieurs VSCode avec le mÃªme profil**
   - Plusieurs instances du mÃªme daemon

4. **Ignorer les warnings de RAM**
   - VSCode te prÃ©vient si Ã§a rame

---

## 10. Tableau RÃ©capitulatif

### Impact sur la RAM

| ScÃ©nario | RAM UtilisÃ©e | RÃ©activitÃ© |
|----------|--------------|------------|
| Toutes extensions | 3-5 GB | Lent ğŸŒ |
| Profil Python seul | 400-600 MB | Rapide âš¡ |
| Profil minimal | 50-150 MB | TrÃ¨s rapide ğŸš€ |

### Temps de DÃ©marrage

| Configuration | DÃ©marrage |
|---------------|-----------|
| Sans profils (20 extensions) | 10-15s |
| Avec profil (5 extensions) | 2-3s |
| Profil minimal | <1s |

---

## ğŸ¯ RÃ©sumÃ©

### Daemon
- Programme en arriÃ¨re-plan permanent
- Consomme de la RAM mÃªme inactif
- NÃ©cessaire pour Ãªtre rÃ©actif

### ProblÃ¨me
- Chaque extension de langage lance un daemon
- 20 extensions = 2-4 GB de RAM gaspillÃ©s

### Solution : Profils
- 1 profil = 1 VSCode avec extensions spÃ©cifiques
- Ã‰conomie de 1.5-3 GB par profil
- DÃ©marrage plus rapide

### Action
1. CrÃ©e un profil par langage
2. N'installe que les extensions nÃ©cessaires
3. Change de profil selon ton travail

**Tu passes de 4 GB Ã  500 MB de RAM utilisÃ©e !** ğŸ’ª

---

## ğŸ“š Ressources

**Documentation VSCode :**
- [Profiles Guide](https://code.visualstudio.com/docs/editor/profiles)
- [Extension API](https://code.visualstudio.com/api)

**Language Server Protocol :**
- [Specification officielle](https://microsoft.github.io/language-server-protocol/)

**Optimisation :**
- [Performance Issues Guide](https://github.com/microsoft/vscode/wiki/Performance-Issues)

---

**Pro Tip Final :** Active le profil AVANT d'ouvrir un projet. Sinon les daemons se lancent quand mÃªme ! ğŸ¯
