# Recherche dichotomique


## Introduction


!!! question "Plus ou moins"
    **Règles:** La machine doit deviner un nombre entre 0 et $n$ que vous aurez choisi.

    **Question:** A votre avis, de quelle manière doit jouer l'ordinateur pour gagner le plus vite possible?
    
    **Ecrire un programme qui:** 
    - Demande au joueur:
        ```text
        Je vais essayer de deviner un entier compris entre 1 et n
        Donne moi la valeur de n et choisis un entier dans ta tête
        ```

    - L'utilisateur entre par exemple 100.

    - L'ordinateur boucle alors en affichant une proposition et en demandant (35 est un exemple de proposition de l'ordinateur):

        ```text
        35. Ton nombre est-il plus grand, moins grand, ou égal? [+/-/=]
        ```
    - Ce à quoi l'utilisateur répond par un des caractères '+', '-' ou '='

    - Le programme se termine lorsque l'ordinateur a trouvé (l'utilisateur a répondu que c'était le bon nombre)

## Recherche dichotomique sur tableau trié

La recherche dichotomique s'inspire de la manière la plus efficace de jouer au "plus ou moins" en divisant l'intervalle de recherche par deux à chaque tentative.

En voici une [Visualisation](https://www.cs.usfca.edu/~galles/visualization/Search.html)

Puis, en voici l'algorithme:

En première lecture, ignorez les lignes 1 et 2. 

```markdown
**ENTRÉE** 
- Un tableau d'entiers T[0..n-1]
- Un entier à trouver val
**SORTIE** 
L'indice du premier élément trouvé, None si la valeur n'appartient pas au tableau.

# Algorithme DICHOTOMIE(T, val)
1. SI n==0 OU T[0]>val
2.      RETOURNER None
3. gauche ← 0
4. droite ← n-1
5. TANT QUE gauche <= droite
6.      milieu ← gauche + (droite - gauche)//2
7.      SI T[milieu] = valeur
8.          RETOURNER milieu
9.      SINON SI T[milieu] > valeur
10.         droite ← milieu - 1
11.     SINON
12.         gauche ← milieu + 1
13. RETOURNER None
```

Le variant de boucle est la quantité droite-gauche+1. Quand elle est égale à 0, l'algorithme termine.

L'invariant est la propriété "La valeur recherchée est dans T[gauche..droite]"

**INITIALISATION**
à l'origine, $gauche=0$ et $droite=n-1$. La valeur recherchée est bien dans T[gauche..droite]

**CONSERVATION**

Faisons l'hypothèse que "La valeur recherchée est dans $T[gauche..droite]$" à l'entrée d'une itération et vérifions que c'est toujours vrai à l'itération suivante.

Nous commençons par calculer l'indice milieu de l'intervalle $[gauche; droite]$.

Nous pouvons donc décomposer notre tableau ainsi:

$$T[gauche..milieu-1] + T[milieu..milieu] + T[milieu+1..droite]$$

Nous avons alors 3 possibilités:
- Si $T[milieu]$ porte la valeur recherchée, on retourne l'indice milieu et l'algorithme s'arrête
- Sinon si $T[milieu]$ est plus grand que la valeur recherchée, vu que $T$ est trié, c'et que la valeur recherchée est dans $T[gauche..milieu-1]$ et justement, on valorise $droite$ à $milieu-1$ 
- Sinon, c'est que la valeur recherchée est dans $T[milieu+1 .. droite]$ et justement, on valorise $gauche$ à $milieu+1$

Dans le premier cas, l'algorithme s'arrête.
Dans les cas où il se poursuit, l'invariant est donc conservé.

**TERMINAISON**
1. **Dans le cas où la valeur est bien présente dans le tableau:** 
Dans le pire des cas, la taille de l'intervalle $[gauche;droite]$ va être divisée par deux de manière continue jusqu'à atteindre 1 et la conservation de l'invariant garantit que la valeur se trouvera dans $T[gauche;droite]$, avec $gauche=droite=milieu$. L'algorithme s'arrête donc bien en renvoyant $T[milieu]$ (Note: la taille d'un intervalle d'entiers est le nombre d'entiers qu'il contient)

2. **Dans le cas où la valeur n'est pas dans le tableau:**
La taille de l'intervalle $[gauche;droite]$ va être divisée par deux de manière continue jusqu'à atteindre 1. Cependant, contrairement au cas précédent, l'indice $milieu$ ne portera pas la valeur recherchée.
Ainsi, que la valeur recherchée soit plus grande ou plus petite que $T[milieu]$, on aura gauche>droite et la boucle se terminera. L'algorithme renverra None.

3. **Dans le cas où la valeur est plus petite que le premier élément du tableau**:
Ce cas est traître en implémentation, mais nous engage à bien définir le domaine de valeurs de nos variables.
On se trouvera à la fin avec $milieu=0$, et $T[milieu]>valeur$.
On va donc exécuter $droite ← milieu - 1$, ce qui va positionner $milieu$ à $-1$
C'est un problème car le domaine de valeurs d'un indice de tableau est un entier non signé (positif). Notez bien que les bidouilles d'indices négatifs sont propres à python.
Par exemple, Rust lèvera une erreur sur ce cas car il n'autorisera pas la variable droite à prendre la valeur -1 attendu qu'elle est obligatoirement positive pour servir d'indice de tableau.
C'est pour ça qu'existent les lignes 1 et 2. On commence par vérifier que la valeur recherchée n'est pas inférieure au premier élément pour ne jamais tomber sur ce cas. On en profite aussi pour régler son compte au cas du tableau vide, car de la même manière, droite ne peut pas valoir -1 en 4ème ligne.